{"./":{"url":"./","title":"简介","keywords":"","body":" 技术交流 QQ群：777164022 EasyClick单机版 解放双手，可编程式、智能化自动点击App；只要会敲键盘就能进行编程！ 简单易编程 丰富的API，图像识别 可脱机运行，可单独发布 支持无障碍/免ROOT运行 智能IDE编程支持 ... EasyClick企业版 云控平台，数千台手机同步运行，节省企业测试成本 不局限地域，任意地方部署设备 云端画面实时同步 定时/非定时执行任务 人机控制同步，人工可介入控制替代自动操作 自带数据分析功能，实时数据报表 ... EasyClick能做什么 App爬虫等 残障人士的辅助，例如语音读书等 自动化测试App ... 适合人群 有意学习自动化测试脚本的人员 希望用自动操作代替手动的人员 企业App测试团队及测试人员 技术交流 QQ群：777164022 在开始之前请阅读用户协议和免责声明，当你开始使用本产品，默认已经接受用户协议和免责声明。 用户协议 免责声明 "},"zh-cn/changelog.html":{"url":"zh-cn/changelog.html","title":"更改记录","keywords":"","body":"当前最新版本: 5.0.0.RC24 5.0.0.RC24: 1、统一全局的Context 2、修复截屏base64有换行问题 3、修复日志悬浮窗部分机型问题 4、新增clipBitmap和base64与bitmap互转函数 5.0.0.RC23: 1、修复随机数函数最后一位不随机的问题 2、修复代理模式下读取res资源问题 3、修复HTTP请求超时不生效问题 4、修复模拟器readFile函数内存溢出的问题 5、新增控制悬浮窗中打开或者关闭日志窗口按钮 6、修复ui.getConfig的方法问题 5.0.0.RC22: 1、优化截图转换base64的异常 2、优化代理模式captureFullScreenEx截屏 5.0.0.RC21: 1、优化脚本工作线程异常捕捉打印 2、优化部分机型截屏内存溢出问题 4、优化单点、多点找色区域 3、新增重启脚本函数 restartScript,适用于自修复脚本和无限循环 5.0.0.RC20: 1、新增sudo和execAgentCommand函数，用于执行命令 2、新增requestEx 网络请求函数，代替request函数 3、优化子线程中断的提示 5.0.0.RC19: 1、修复部分设备不预览工程，直接运行报错问题 5.0.0.RC18: 1、修复无障碍横屏竖屏切换截图问题 2、修复图色对话框的问题 3、新增UI和脚本共享存储区存储数据和变量，给脚本使用 4、修复java插件调试不更新问题 5.0.0.RC17 1、新增单点、多点比色函数 2、新增多点多数组比色函数 3、完善截图横屏的处理 4、新增二值化图片函数 5、修复findColor找色临界值的问题 5.0.0.RC16 1、优化日志悬浮窗，美化关闭按钮 2、优化UI和脚本交互，脚本中可以访问UI模块的方法和变量等 3、优化HTTP异常日志显示 5.0.0.RC15 1、新增addNodeFlag和removeNodeFlag可用于强制刷新节点信息 2、新增execScript执行脚本函数，动态执行js文件或者内容 3、优化屏幕映射的图像画质 4、优化IDEA抓取节点时候，释放节点锁，刷新节点 5.0.0.RC14 1、优化部分模拟器无法激活的问题 2、修复找色精度的问题 3、优化输入法新增输入keyCode 5.0.0.RC13 1、优化openApp和openAppByName函数 2、优化保活 3、优化激活程序 5.0.0.RC12 1、新增热更新对整型版本的兼容 2、日志是否显示行号，新增setFloatDisplayLineNumber函数 3、补充企业版本中控函数 4、修复从悬浮窗启动不自动保存数据问题 5.0.0.RC11 1、远程调试默认不重连 2、IDEA新增踢下线功能 3、修复selected属性不生效问题 4、修复特殊字符串使用text查找不到的问题 5.0.0.RC10 1、新增IDEA java与js混合开发 2、去除音量键控制 3、新增脚本的结束和异常的监听 4、新增远程记录 5、优化远程调试截图压缩 6、修复多点找色为负数的卡住问题 7、新增代理模式下captureFullScreenEx方法，代理下尽力消除色差问题 5.0.0.RC9 1、修复某些情况停止线程的问题 2、修复dex打包问题 3、修复远程调试异常问题 5.0.0.RC8 1、修复代理模式下ui中iServiceOk读取的问题 2、修复IDEA编译IEC的加密读取问题 5.0.0.RC7: 1、修复远程调试连接部分问题 2、修复直接启动脚本偶尔服务环境判断异常问题 5.0.0.RC6: 1、优化日志打印 2、开启新的输入法进程 3、优化编译文件删除不了的问题 4、JS和dex编译支持多目录结构 5、修复插件开发，运行时候不能运行最新代码问题 6、修复UI和脚本调用isServiceOk结果不一致的问题 7、新增clearLog函数，用于清除日志框的日志 8、新增远程调试 5.0.0.RC5: 1、还原代理模式和无障碍模式，同422版本 5.0.0.RC4： 1、修复特殊情况下脚本无法停止问题 2、修复启停悬浮窗按钮和日志框状态同步问题 3、修复UI对日志框操作的问题 5.0.0.RC3 1、优化热更新新增含有对话框的更新方式 2、优化其他功能 5.0.0.RC2 1、无障碍截图修改不带缓存模式 2、修复ui预览的可能出现多个tab问题 3、修复打印log带{}会出现的问题 4、补充并完善文档，补充脚本与原生UI，H5 UI交互文档 5.0.0.RC1 1、新增UI和脚本交互 2、新增线程停止全部 stopAll方法 3、新增UI alert和input、自定义视图的对话框 4、新增找色带方向参数，新增setInitParam全局图色参数 5、新增脚本和UI对EC的系统参数进行设置 setECSystemConfig 6、新增重建截屏权限功能，用于重试IDEA截屏 7、拆分IDEA的节点属性的activity-class-name 8、优化日志悬浮窗展示，setSaveLog方法，增加自定义日志路径，日志分隔尺寸 9、修改图色查找参数原x,y,w,h 为 x,y,ex,ey全坐标模式 10、优化打包配置跟随项目而定 11、去除热更新和http模块下载文件断点功能，防止有的服务器不返回长度造成的错误 12、统一节点服务，优化代理独占节点服务问题 13、拆分之前运行模式为 节点服务，底层代理服务，手势服务 4.22.0 1、优化线程遇到异常的日志打印 2、新增日志的可变参数 3、新增IDEA更新后，覆盖老的libs文件中的js文件 4.20.0 1、新增WIFI连接历史记录 2、优化IDEA日志打印代码跳转，错误日志也可以跳转 3、优化IDEA日志打印object,自动转成JSON字符串 4、修复雷电和逍遥模拟器使用dex模式运行错误问题 5、修复websocket onBinary问题 6、新增原生UI监听Activity生命周期函数 onActivityEvent 7、开放5.0以上的无障碍服务，新增longClickEx、clickRandomEx 无指针点击 8、修复热更新服务端不返回，会回退到当前打包的版本 9、修复Webview的文件选择问题 10、新增toast1和toast2方法，兼容机型 11、新增setLogViewSizeEx 扩展设置日志窗口 12、新增H5和原生UI中的openActivity函数 13、优化随机函数和打包覆盖IEC文件问题 4.15.0 1、新增jslog行号，IDEA点击行号可以直接链接过去 2、新增打包时候更改无障碍服务名称和更改输入法名称 3、新增源码编译为dex功能 4、新增脚本中websocket支持 5、新增无障碍setGestureActionMode函数，控制手势事件返回结果是同步还是异步 6、新增保存节点和载入节点功能 7、新增保存iec文件路径和获取的函数 8、修复代理模式getToast问题 9、优化截图部分机型卡住的问题 4.7.0 1、新增在有权限的情况下支持开机自启动脚本 2、新增锁定节点缓存和释放节点缓存方法，不使用最新的节点数据 3、修复无障碍模式下previousSiblings和nextSiblings的问题 4.5.0 1、新增保存当前截图的图片，给取色取图使用 2、新增JS scrollForward、scrollBackward、scrollLeft、scrollRight、scrollUp、scrollDown 方法 3、新增JS 无指针的点击方法clickEx 4、优化IDEA日志滚动问题 5、优化线程停止 6、修复webview的轮播图不滑动问题 7、修复原生UI高度和宽度不填写不生效的问题 8、优化输入法输入，兼容不传参数的模式 9、优化click函数点击的问题 4.2.7 : 1、新增js的power电源键方法 2、js类库根据字母排序 3、开发工具数据目录到用户.config/easyclick目录，避免污染整体环境 4、激活模式更改为4种，和激活工具一样 5、修复抓取屏幕的参数不正确的容错 6、修复截屏的时顺带启动EC界面的问题 7、优化启停控制悬浮窗开放js控制 4.2.0 : 1、新增自动保存代码 2、新增插件菜单，一键jar转换和打包插件工程 3、优化控制悬浮窗授权后，再次启动 4、开发工具日志打印的info中方便排查问题 5、修复代理模式在部分设备无法启动 4.0.8 : 1、修复截屏部分异常问题 2、优化设备激活 3、优化EC安装时的提示 4、优化文件函数新增listDir 4.0.5 : 1、修复取色器取色不正确的问题 2、优化随机函数 3、优化节点搜索不区分大小写，回车键可以搜索 4、修复加密时候热更新问题 5、优化ADB和ADB路径的选择 4.0.0 : 1、新增悬浮窗启停脚本 2、新增异步线程的停止等方法 3、新增原生UI与JS交互支持，新增ImageView、CardView、Switch组件 4、新增IEC文件的加密强度 5、新增IDEA EC模板文件选择 6、新增IDEA节点代码生成、节点搜索功能 7、新增IDEA编译加密IEC包菜单 8、新增IDEA取色工具和生成找色代码等功能 9、新增IDEA WIFI直连设备功能 10、重写多点找色功能查找和市面产品相近 11、修改自动化服务状态到脚本中判断 12、优化设备激活，ADB过滤无效设备 13、优化去除打包时的包名长度限制 14、优化Android Q提示老版本的问题 15、优化对IDEA 2020版本的支持 16、修复nid重复导致parent()不正确的问题 17、修复webview加载部分资源不正确的问题 3.6.6 : 1、还原单个截取全屏函数 2、新增获取截图Bitmap的函数 3、新增getPixelsBitmap和getPixelBitmap获取bitmap的颜色值 3.6.4 : 1、修复openActivity的部分问题 2、升级opencv为最新版本 3、新增企业版本控制节本状态接口 4、新增IDEA节点查看器的checked属性 5、新增子节点的级联搜索 3.6.0 : 1、新增定时任务函数 2、新增打开App即运行脚本开关功能 3、节点新增bounds范围查找 4、新增脚本热更新 5、新增点击节点中心点的函数 6、新增企业版本开放式节点接口 7、新增点击节点中心点的函数 8、新增webview错误输出到控制台 9、IDEA新增打开adb命令控制台 10、新增Sqlite3操作模块 11、修复图色模块toBase64方法 3.5.3 : 1、新增MetreUI模板 2、新增节点、activity等待和超时函数 3、新增悬浮窗权限检测和悬浮窗自定义视图 4、优化正则匹配，优化节点查找 5、优化activity-class 获取 3.5.0: 1、新增IDE插件的编写 2、新增HTML模板支持和js控制窗口方法 3、新增WebView控件支持 4、新增粘贴到输入框的方法 5、增加无障碍下的多点触摸 6、新增图色模块中将图片转成base64和区域剪切方法 7、新增部分选择节点的属性 8、http请求异常提示反馈到IDEA ,默认忽略请求错误问题 9、删除部分不用的方法，新增部分节点快捷选择方法 10、优化Toast展示 11、优化图色截图速度30ms以下，区域找色找图100ms以下 3.4.5: 1、新增读取IEC文件包的资源方法 2、新增Http请求的万能方法 3、新增多点触摸函数 4、新增剪贴板读取和设置功能 5、新增IDEA工具暂停脚本功能 6、新增IDEA取图功能，优化图色查找 7、优化打包和签名 8、优化获取节点数据时候强制刷新，保证是最新数据 9、修复获取UI参数的缓存问题 3.4.2: 1、优化新增悬浮窗字体设置 3、增加抓取节点模式setFetchNodeMode 4、优化IDE获取界面元素的逻辑 5、新增IDE 预览 运行 打包快捷键 3.4.0: 1、新增NodeInfo节点直接操作的方法,例如parent、click等方法 2、新增JavaScript根据获取所有节点的属性方法 3、新增新增保存日志到文件中 4、新增打包是否显示设置 5、修复模拟器下UI的错误 3.3.0: 1、新增JavaScript loaddex载入dex/apk方法 2、新增JavaScript loadjar载入jar包的方法 3、新增JavaScript exit退出脚本方法 4、新增JavaScript更改UI参数的方法 5、新增JavaScript设置悬浮窗大小方法,优化展示 6、优化UI界面，新增多TAB支持 7、新增IDE调试环境参数同步到手机 8、修改屏幕映射菜单按钮为任务按钮 9、优化设备激活检测 3.2.0: 1、新增depth选择器 2、新增drawingOrder选择器 3、修复日志浮窗问题 4、优化代理模式选择器效率 3.0.1: 1、修复脚本暂停问题 3.0.0: 1、新增设备连接 2、新增预览、运行、打包工程 3、新增节点查看 4、新增同屏映射 "},"zh-cn/getting-start.html":{"url":"zh-cn/getting-start.html","title":"开始","keywords":"","body":"下载开发工具 百度网盘下载 提取码：7bhy 天翼云下载 密码：nup3 QQ群下载：777164022 下载idea开发工具，文件以idea-xxx开头的，也可以自行到idea官网下载 IDEA官网下载地址 网页地址：https://www.jetbrains.com/idea/download/other.html 商业版本JS智能提示：2019.3.4 for Windows (exe) https://download.jetbrains.com/idea/ideaIU-2019.3.4.exe 社区版本(免费)：2019.3.4 for Windows (exe) https://download.jetbrains.com/idea/ideaIC-2019.3.4.exe 安装后，打开bin/idea64.exe文件开始运行 下载EasyClick最新版本的IDEA插件，并按照到IDEA中，安装教程：https://blog.csdn.net/qq_35246620/article/details/78289074 创建工程 创建成功 连接设备 点击菜单 'EasyClick开发工具' - '设备连接' 选择任意一个连接方式 运行程序 预览UI 运行工程，如果运行失败提示无权限，可以点击菜单 'EasyClick开发工具' - '激活设备' "},"zh-cn/download_resources.html":{"url":"zh-cn/download_resources.html","title":"资源下载","keywords":"","body":"开发工具 百度网盘下载 提取码：7bhy 天翼云下载 密码：nup3 QQ群下载：777164022 下载idea开发工具，文件以idea-xxx开头的，也可以自行到idea官网下载 IDEA官网下载地址 网页地址：https://www.jetbrains.com/idea/download/other.html 商业版本JS智能提示：2019.3.4 for Windows (exe) https://download.jetbrains.com/idea/ideaIU-2019.3.4.exe 社区版本(免费)：2019.3.4 for Windows (exe) https://download.jetbrains.com/idea/ideaIC-2019.3.4.exe 源码类库区 Github仓库 触动、按键插件 按键-EC插件下载 触动-EC插件下载 "},"zh-cn/funcs/devtools/dev-tools.html":{"url":"zh-cn/funcs/devtools/dev-tools.html","title":"开发工具介绍","keywords":"","body":" 安装 工程相关 设备相关 屏幕相关 设置相关 远程调试 "},"zh-cn/funcs/devtools/dev-tools-install.html":{"url":"zh-cn/funcs/devtools/dev-tools-install.html","title":"安装","keywords":"","body":"开发环境安装 百度网盘下载 提取码：7bhy 天翼云下载 密码：nup3 QQ群下载：777164022 下载idea开发工具，文件以idea-xxx开头的，也可以自行到idea官网下载 IDEA官网下载地址 网页地址：https://www.jetbrains.com/idea/download/other.html 商业版本JS智能提示：2019.3.4 for Windows (exe) https://download.jetbrains.com/idea/ideaIU-2019.3.4.exe 社区版本(免费)：2019.3.4 for Windows (exe) https://download.jetbrains.com/idea/ideaIC-2019.3.4.exe 安装后，打开bin/idea64.exe文件开始运行 下载EasyClick最新版本的IDEA插件，并按照到IDEA中，安装教程：https://blog.csdn.net/qq_35246620/article/details/78289074 主界面预览 "},"zh-cn/funcs/devtools/dev-tools-project.html":{"url":"zh-cn/funcs/devtools/dev-tools-project.html","title":"工程相关","keywords":"","body":"工程相关 创建工程 创建成功 预览工程 菜单 'EasyClick开发工具' - '预览工程' 在工程或者源码文件上点击右键选择 '预览工程' 预览工程会将UI视图直接在手机预览 运行工程 菜单 'EasyClick开发工具' - '运行工程' 在工程或者源码文件上点击右键选择 '运行工程' 运行工程会直接在手机上运行脚本，所有的日志在'EasyClick运行日志'可看到 打包 菜单 'EasyClick开发工具' - '打包工程' 在工程或者源码文件上点击右键选择 '打包工程' 打包工程会编译源码并输入apk文件，所有的日志在'EasyClick运行日志'可看到 "},"zh-cn/funcs/devtools/dev-tools-device.html":{"url":"zh-cn/funcs/devtools/dev-tools-device.html","title":"设备相关","keywords":"","body":"设备相关 菜单栏-EasyClick开发工具-设备连接 设备连接 USB连接 WIFI连接 WIFI连接是指需要再手机上开启无线调试模式， 点击wifi连接，然后输入手机ip地址即可 教程: https://www.jianshu.com/p/a9543f2e89de 二维码安装 如果部分手机无法安装上EC调试版程序，可以使用扫码方式安装 设备激活 菜单栏-EasyClick开发工具-激活设备 激活设备实现免root运行脚本 激活设备可以实现自动开启无障碍，无需手动开启 "},"zh-cn/funcs/devtools/dev-tools-screen.html":{"url":"zh-cn/funcs/devtools/dev-tools-screen.html","title":"屏幕相关","keywords":"","body":"屏幕相关 菜单栏-EasyClick开发工具-节点抓取节点抓取 点击节点抓取按钮，可以获取当前的屏幕元素 可以在抓取的屏幕上进行点击，选择元素 可以在节点属性窗口，复制节点的值 同屏映射 点击屏幕映射按钮，可以连接到当前的设备屏幕，实时预览和操作 如果窗口太小，可以点击右上方的三点按钮，使得窗口进行浮动起来 找色找图操作 点击节点抓取按钮，可以获取当前的屏幕元素 在图片上点击右键，选择图色模式 在图片上想要的区域，拖动出一个矩形框 点击右键选择 取色，然后设置想要取得色块的矩阵大小，点击确定，然后根据提示生成代码即可 找图：直接选择找图菜单，将图片保存到工程目录下的res文件夹中 "},"zh-cn/funcs/devtools/dev-tools-settings.html":{"url":"zh-cn/funcs/devtools/dev-tools-settings.html","title":"设置","keywords":"","body":"设置相关 设置 菜单栏-EasyClick开发工具-EasyClick设置 设置包括了和屏幕映射相关的属性 "},"zh-cn/funcs/devtools/dev-tools-remote.html":{"url":"zh-cn/funcs/devtools/dev-tools-remote.html","title":"远程调试","keywords":"","body":"远程调试 先在手机上安装EC调试版本 菜单栏-EasyClick开发工具-设备连接-扫码安装APK 可以下载安装或者扫码安装 开启远程调试 菜单栏-EasyClick开发工具-设备连接-远程调试 在弹出框中，输入本地的端口，默认是 10825，点击确定，开启本地端口，注意观察EasyClick运行日志栏 路由器暴露端口 默认路由器地址一般是 ：http://192.168.1.1，本文档依次为例，路由器是TPLINK，在浏览器输入网址：http://192.168.1.1 找到虚拟服务器 找到虚拟服务器 找到外网IP 在手机上EC进行连接 在手机上打开EC调试程序 进入远程连接页面 输入信息进行连接 FRP反向代理 使用FRP软件进行反向代理，需要将电脑端口映射到服务器，然后手机连接服务器IP即可，这样就不用路由器IP了 "},"zh-cn/funcs.html":{"url":"zh-cn/funcs.html","title":"功能函数","keywords":"","body":" 全局模块 全局快捷事件 选择器&节点 无障碍事件 代理事件 图色函数 设备函数 文件函数 网络函数 线程函数 常用工具函数 Shell命令函数 Sqlite命令函数 "},"zh-cn/funcs/global/global.html":{"url":"zh-cn/funcs/global/global.html","title":"全局模块","keywords":"","body":"说明 全局模块是指直接调用方法就可以使用的模块，无需使用前缀对象名称 模块加载 loadDex 载入dex或者apk 载入dex文件 @param path 路径，加载顺序分别是插件目录(例如 ab.apk)或者是文件路径(例如 /sdcard/ab.apk)加载 @return true 载入成功， false载入失败 function main(){ //类似这样会先从IEC文件的插件目录查找 //loadDex(\"ocr.apk\"); //下面这个是从sdcard查找 loadDex(\"/sdcard/a.apk\"); // a.apk中存在com.A这个这个类，可以直接使用 var obj = new com.A(); } main(); loadJar 载入jar 载入jar文件 @param path 路径，加载顺序分别是插件目录(例如 ab.jar)或者是文件路径(例如 /sdcard/ab.jar)加载 @return true 载入成功， false载入失败 function main(){ loadJar(\"/sdcard/a.jar\"); // a.jar中存在com.A这个这个类，可以直接使用 var obj = new com.A(); } main(); 动态执行JS execScript 载入JS 执行JS文件或者内容 @param type 1=文件，2=直接是JS内容 @param content 路径例如/sdcard/a.js或者js的内容 @return 布尔型，true代表执行成功， false代表失败 function main(){ var d ='while(true){sleep(1000);logd(111111);}'; thread.execAsync(function() { //execScript(1,\"/sdcard/ad.js\") execScript(2,d); }); while(true){ sleep(2000); loge(\"fsadffsad\") } } main(); 重启脚本 restartScript 重启脚本，适合无限循环，或者有异常的情况可以下载最新的iec再次执行，避免进入UI才能热更新, 注意: 该方法威力巨大，请自行控制好是否自动重启，否则只能强杀进程才能停止 @param path 新的IEC路径，如果不需要可以填写null @param stopCurrent 是否停止当前的脚本 @param delay 延迟多少秒后执行 @return bool true 代表成功 false 代表失败 function main(){ logd(\"我是在脚本运行的\"); setStopCallback(function(){ restartScript(null,false,3) }); //setExceptionCallback(function (){ // restartScript(null,true,3) //}); sleep(1000); logd(\"脚本结束\") } main(); importClass 导入JAVA类 导入java的class给js用 @param clz class的名称例如: com.A function main(){ importClass(com.A); var obj = new com.A(); } main(); importPackage 导入JAVA包 导入java包下面所有类给js用 @param clz class的名称例如: com.b function main(){ importPackage(com.b); var obj = new com.b.A(); } main(); JSON.stringify 格式化为JSON字符串 格式化对象为JSON字符串 @param 对象 function main(){ var m ={\"sss\":\"a\"}; var d =JSON.stringify(m); toast(d); } main(); JSON.parse 转换为JSON对象 格式化JSON字符串为对象 @param 字符串 function main(){ var m ={\"sss\":\"a\"}; var d =JSON.stringify(m); d =JSON.parse(d); toast(d); } main(); 监听脚本 setStopCallback 脚本停止监听 function main(){ setStopCallback(function (){ logd(\"fdsafsad 我是停止回调\") }); var result = sleep(1000); if (result){ toast(\"成功\"); } else { toast(\"失败\"); } } main(); setExceptionCallback 脚本异常停止监听 function main(){ setExceptionCallback(function (msg){ logd(\" 异常停止消息: \"+msg) }); var result = sleep(1000); if (result){ toast(\"成功\"); } else { toast(\"失败\"); } //这里有异常抛出 result.length(); } main(); 退出脚本 exit exit(); 暂停执行 sleep 休眠 @param miSecond 毫秒 function main(){ var result = sleep(1000); if (result){ toast(\"成功\"); } else { toast(\"失败\"); } } main(); 日志消息方法 setSaveLog 设置保存日志信息到文件中 @param save 是否保存 @param path 自定义的文件夹 @param size 每个文件分隔的尺寸 @return 保存日志文件的目录 function main(){ var s = setSaveLog(true,\"/sdcard/aaa/\",1024*1024); logd(\"save dir is:\"+s); } main(); setFloatDisplayLineNumber 打印日志的时候，悬浮窗是否展示行号，正式发布，可以不展示行号，不影响调试和保存在文件的日志中 @param ds true 代表显示， false 不显示 function main(){ setFloatDisplayLineNumber(true); } main(); toast 显示Toast消息 @param msg 消息字符串 function main(){ toast(\"msg\"); } main(); toast1 显示Toast消息 (扩展方法) @param msg 消息字符串 function main(){ toast1(\"msg\"); } main(); toast2 显示Toast消息(扩展方法) @param msg 消息字符串 function main(){ toast2(\"msg\"); } main(); logd 调试日志 @param msg 消息字符串 function main(){ logd(\"msg\"); //可变参数写法 logd(\"我是消息{},{}\",\"测试1\",2) } main(); loge 错误日志 @param msg 消息字符串 function main(){ loge(\"msg\"); //可变参数写法 loge(\"我是消息{},{}\",\"测试1\",2) } main(); logw 警告日志 @param msg 消息字符串 function main(){ logw(\"msg\"); //可变参数写法 logw(\"我是消息{},{}\",\"测试1\",2) } main(); logi 信息日志 @param msg 消息字符串 function main(){ logi(\"msg\"); //可变参数写法 logi(\"我是消息{},{}\",\"测试1\",2) } main(); clearLog 清除日志 @param lines 整型，要清除的行数，-1 代表全部清除 function main(){ showLogWindow() sleep(1000) for (var i = 0; i 读取IEC包资源 readResString 读取res文件夹中的资源文件,并返回字符串 @param fileName 文件名称，不要加res前缀 @return string 如果是null代表没内容 function main(){ var testData = readResString(\"a.txt\"); } main(); readResBitmap 读取res文件夹中的资源文件，并返Bitmap图片对象 @param fileName 文件名称，不要加res前缀 @return string 如果是null代表没内容 function main(){ var b = readResBitmap(\"a.txt\"); } main(); readResAutoImage 读取res文件夹中的资源文件，并返 AutoImage 图片对象 @param fileName 文件名称，不要加res前缀 @return string 如果是null代表没内容 function main(){ var b = readResAutoImage(\"img/a.png\"); } main(); saveResToFile 保存res文件夹中的资源文件到指定的路径 @param fileName 文件名称，不要加res前缀 @param path 要保存到的路径地址，例如/sdcard/aa.txt @return boolean|布尔型 true代表保存成功 function main(){ var b = saveResToFile(\"img/a.png\",\"/sdcard/a.png\"); } main(); UI参数读取 readConfigInt @description 读取UI界面中的参数,返回是整型 @param key 在UI界面中配置的key @return 整型，找不到就返回0 function main(){ var testData = readConfigInt(\"test_key\"); } main(); readConfigString 读取UI界面中的参数,返回是字符串 @param key 在UI界面中配置的key @return 字符串 找不到就返回空字符串 function main(){ var testData = readConfigString(\"test_key\"); } main(); readConfigDouble 读取UI界面中的参数,返回是Double型 @param key 在UI界面中配置的key @return double function main(){ var testData = readConfigDouble(\"test_key\"); } main(); readConfigBoolean 读取UI界面中的参数,返回是布尔型 @param key 在UI界面中配置的key @return true 或者 false function main(){ var testData = readConfigDouble(\"test_key\"); } main(); getConfigJSON 取得配置的JSON @return JSON数据 function main(){ var testData = getConfigJSON(); } main(); updateConfig 更新配置 @param key 键 @param value 值 @return {boolean} true 成功，false失败 function main(){ updateConfig(\"a\",\"sss\"); } main(); EC 系统设置 setECSystemConfig 设置EC的系统参数 @param params map形式例如 {\"running_mode\":\"无障碍\"}, { \"running_mode\":\"无障碍\", \"auto_start_service\":\"是\", \"log_float_window\":\"否\", \"ctrl_float_window\":\"否\" } 参数解释有： running_mode : 运行模式 值有 无障碍，代理两种 auto_start_service： 开机自启动 值有 是，否 两种 log_float_window : 日志悬浮窗展示 值有 是，否 两种 ctrl_float_window : 启停控制悬浮窗展示 值有 是，否 两种 * @return 布尔型 true 是 false 否 function main(){ var m = { \"node_service\":\"需要\", \"proxy_service\":\"不需要\", \"running_mode\":\"无障碍\", \"log_float_window\":\"否\", \"ctrl_float_window\":\"否\" }; setECSystemConfig(m); } main(); openECSystemSetting 打开EC系统设置页面 @return true 成功 false 失败 function main(){ var result = openECSystemSetting(); } main(); 设置IEC文件(脚本中的热更新) setIECPath 设置要执行的IEC文件路径 @return true 成功 false 失败 function main(){ var result = setIECPath(\"/sdcard/release.iec\"); logd(\"result : \"+result); logd(\"当前路径 \"+getIECPath()); //开启定时任务准备下一次执行 var id2 =startJob(\"task2\",\"2\",true); logd(\"job id \"+id2); } main(); 运行模式 isAccMode 是否是无障碍模式 @return true或者false function main(){ var result = isAccMode(); } main(); isAgentMode 是否是代理模式 @return true或者false function main(){ var result = isAgentMode(); } main(); isServiceOk 自动化服务是否正常 @return true或者false function main(){ var result = isServiceOk(); } main(); startEnv 启动自动化服务环境 @return true或者false function main(){ var result = startEnv(); } main(); "},"zh-cn/funcs/global/global-shortcut.html":{"url":"zh-cn/funcs/global/global-shortcut.html","title":"全局快捷事件","keywords":"","body":"说明 全局模块中封装的快捷事件，不用区分是无障碍模式还是代理模式 手势事件模式 setGestureActionMode 设置各种手势模式事件的操作类型，默认是异步,目前只对无障碍模式有效 @param mode 1 代表异步，2代表同步 @param bool true代表成功 false代表失败 function main(){ setGestureActionMode(1); // setGestureActionMode(2); } main(); 点击函数 clickPoint 执行条件：无障碍7.0以上或者手势执行为代理服务 点击坐标 @param x x坐标 @param y y坐标 @return {boolean|布尔型} function main(){ var result = clickPoint(100,100); if (result){ toast(\"点击成功\"); } else { toast(\"点击失败\"); } } main(); click 执行条件：无障碍7.0以上或者手势执行为代理服务 点击选择器 @param selectors 选择器对象 @return {boolean|布尔型} function main(){ var selector = text(\"我是文本\"); var result = click(selector); if (result){ toast(\"点击成功\"); } else { toast(\"点击失败\"); } } main(); clickEx 执行条件：无障碍5.0以上或者手势执行为代理服务 无指针方式点击选择器，节点必须是可点击的才行 @param selectors 选择器对象 @return {boolean|布尔型} function main(){ var selector = text(\"我是文本\"); var result = clickEx(selector); if (result){ toast(\"点击成功\"); } else { toast(\"点击失败\"); } } main(); longClickEx 执行条件：无障碍5.0以上或者手势执行为代理服务 无指针方式长点击选择器，节点必须是可点击的才行 @param selectors 选择器对象 @return {boolean|布尔型} function main(){ var selector = text(\"我是文本\"); var result = longClickEx(selector); if (result){ toast(\"点击成功\"); } else { toast(\"点击失败\"); } } main(); clickRandom 执行条件：无障碍7.0以上或者手势执行为代理服务 随机点击选择器的任意元素 @param selectors 选择器对象 @return {boolean|布尔型} function main(){ var selector = text(\"我是文本\"); var result = clickRandom(selector); if (result){ toast(\"点击成功\"); } else { toast(\"点击失败\"); } } main(); clickRandomEx 执行条件：无障碍5.0以上或者手势执行为代理服务 随机点击选择器的任意元素 @param selectors 选择器对象 @return {boolean|布尔型} function main(){ var selector = text(\"我是文本\"); var result = clickRandomEx(selector); if (result){ toast(\"点击成功\"); } else { toast(\"点击失败\"); } } main(); clickRandomRect 执行条件：无障碍7.0以上或者手势执行为代理服务 随机点击区域中的坐标 @param rect 区域对象 @return {boolean|布尔型} function main(){ var rect = new Rect(); rect.left = 10; rect.right = 200; rect.top = 10; rect.bottom = 400; var result = clickRandomRect(rect); if (result){ toast(\"点击成功\"); } else { toast(\"点击失败\"); } } main(); clickCenter 执行条件：无障碍7.0以上或者手势执行为代理服务 点击区域中的中心坐标 @param rect 区域对象 @return {boolean|布尔型} function main(){ var rect = new Rect(); rect.left = 10; rect.right = 200; rect.top = 10; rect.bottom = 400; var result = clickCenter(rect); if (result){ toast(\"点击成功\"); } else { toast(\"点击失败\"); } } main(); clickText 执行条件：无障碍7.0以上或者手势执行为代理服务 点击文本 @param text 文本 @return {boolean|布尔型} function main(){ var result = clickText(\"设置\"); if (result){ toast(\"点击成功\"); } else { toast(\"点击失败\"); } } main(); longClick 执行条件：无障碍7.0以上或者手势执行为代理服务 长点击选择器 @param selectors 选择器对象 @return {boolean|布尔型} function main(){ var selector = text(\"我是文本\"); var result = longClick(selector); if (result){ toast(\"点击成功\"); } else { toast(\"点击失败\"); } } main(); longClickPoint 执行条件：无障碍7.0以上或者手势执行为代理服务 长点击坐标 @param x x坐标 @param y y坐标 @return {boolean|布尔型} function main(){ var result = longClickPoint(100,100); if (result){ toast(\"点击成功\"); } else { toast(\"点击失败\"); } } main(); 多点触摸 multiTouch 多点触摸 执行条件：无障碍7.0以上或者手势执行为代理服务 多点触摸 触摸参数: action :一般情况下 按下为0，弹起为1，移动为2 x: X坐标 y: Y坐标 pointer：设置第几个手指触摸点，分别是 1，2，3等，代表第n个手指 delay: 该动作延迟多少毫秒执行 @param touch1 第1个手指的触摸点数组,例如：[{\"action\":0,\"x\":1,\"y\":1,\"pointer\":1,\"delay\":20},{\"action\":2,\"x\":1,\"y\":1,\"pointer\":1,\"delay\":20}] @param touch2 第2个手指的触摸点数组 @param touch3 第3个手指的触摸点数组 @param timeout 多点触摸执行的超时时间，单位是毫秒 @return boolean|布尔型 function main() { utils.openAppByName(\"视频\"); sleep(3000); //第一种数组式的写法 var touch1 = [ {\"action\": 0, \"x\": 500, \"y\": 1200, \"pointer\": 1, \"delay\": 1}, { \"action\": 2, \"x\": 500, \"y\": 1100, \"pointer\": 1, \"delay\": 20 }, { \"action\": 2, \"x\": 500, \"y\": 1000, \"pointer\": 1, \"delay\": 20 }, { \"action\": 1, \"x\": 1, \"y\": 1, \"pointer\": 1, \"delay\": 20 }]; //第二种链式调用方法 var touch1 = MultiPoint .get() .action(0).x(500).y(1200).pointer(1).delay(1) .next() .action(2).x(500).y(1100).pointer(1).delay(1) .next() .action(2).x(500).y(1000).pointer(1).delay(1) .next() .action(2).x(500).y(900).pointer(1).delay(1) .next() .action(1).x(500).y(800).pointer(1).delay(1); var touch2 = MultiPoint .get() .action(0).x(300).y(1200).pointer(2).delay(1) .next() .action(2).x(300).y(1100).pointer(2).delay(1) .next() .action(2).x(300).y(1000).pointer(2).delay(1) .next() .action(2).x(300).y(900).pointer(2).delay(1) .next() .action(1).x(300).y(800).pointer(2).delay(1); var x = multiTouch(touch1, touch2, null, 30000); logd(\"xxs \" + x); } main(); 滚动函数 scrollForward 执行条件：无障碍5.0以上或者手势执行为代理服务 向前滚动 @param selectors 选择器对象 @return {boolean|布尔型} function main(){ var selector = scrollable(true); var result = scrollForward(selector); if (result){ toast(\"滚动成功\"); } else { toast(\"滚动失败\"); } } main(); scrollBackward 执行条件：无障碍5.0以上或者手势执行为代理服务 向后滚动 @param selectors 选择器对象 @return {boolean|布尔型} function main(){ var selector = scrollable(true); var result = scrollBackward(selector); if (result){ toast(\"滚动成功\"); } else { toast(\"滚动失败\"); } } main(); 滑动函数 swipe 执行条件：无障碍7.0以上或者手势执行为代理服务 通过选择器滑动节点 @param selectors 节点选择器 @param endX 结束的X坐标 @param endY 结束的Y坐标 @param duration 持续时长 单位毫秒 @return 布尔型 true 代表成功 false 代表失败 function main(){ var selectors = text(\"我是文本\"); var result = swipe(selectors,100,100,200); if (result){ toast(\"滑动成功\"); } else { toast(\"滑动失败\"); } } main(); swipeToPoint 执行条件：无障碍7.0以上或者手势执行为代理服务 从一个坐标滑动到另一个坐标 @param startX 起始坐标的X轴值 @param startY 起始坐标的Y轴值 @param endX 结束坐标的X轴值 @param endY 结束坐标的Y轴值 @param duration 持续时长 单位毫秒 @return 布尔型 true 滑动成功, false 滑动失败 function main(){ var result = swipeToPoint(10,10,100,100,200); if (result){ toast(\"滑动成功\"); } else { toast(\"滑动失败\"); } } main(); isScrollEnd 执行条件：无障碍5.0以上或者手势执行为代理服务 是否滚动到底部了，如果查不到元素也会返回false @param distance 滚动方向 UP,DOWN,LEFT,RIGHT @param selectors 选择器 @return false 代表未滚动到位，true 代表滚动完成了 function main(){ var selectors = clz(\"android.widget.ListView\"); var result = isScrollEnd(\"UP\",selectors); if (result){ toast(\"滚动完成\"); } else { toast(\"滚动未完成\"); } } main(); 拖动函数 drag 执行条件：无障碍7.0以上或者手势执行为代理服务 从一个坐标到另一个坐标的拖动 @param startX 起始坐标的X轴值 @param startY 起始坐标的Y轴值 @param endX 结束坐标的X轴值 @param endY 结束坐标的Y轴值 @param duration 持续时长 单位毫秒 @return 布尔型 true 拖动成功, false 拖动失败 function main(){ var result = drag(10,10,100,100,200); if (result){ toast(\"拖动成功\"); } else { toast(\"拖动失败\"); } } main(); dragTo 执行条件：无障碍7.0以上或者手势执行为代理服务 通过选择器拖动某个元素到目标元素 @param selectors 选择器 {@link S} @param destObj 目标元素选择器 @param duration 持续时长 单位毫秒 @return 布尔型 true 成功 false 失败 function main(){ var selectors = text(\"设置\"); var destObj = text(\"日历\"); var result = dragTo(selectors,destObj,200); if (result){ toast(\"拖动成功\"); } else { toast(\"拖动失败\"); } } main(); dragToPoint 执行条件：无障碍7.0以上或者手势执行为代理服务 通过选择器拖动某个元素到目标X Y 坐标 @param selectors 原始元素选择器 @param endX 目标 X 坐标 @param endY 目标 Y 坐标 @param duration 持续时长 单位毫秒 @return 布尔型 true 成功 false 失败 function main(){ var selectors = text(\"设置\"); var result = dragToPoint(selectors,100,100,200); if (result){ toast(\"拖动成功\"); } else { toast(\"拖动失败\"); } } main(); 输入数据 currentIsOurIme 当前是否是我们的输入法 @return {boolean|布尔型} function main(){ var result = currentIsOurIme(); if (result){ toast(\"是\"); } else { toast(\"否\"); } } main(); inputText 执行条件：无障碍5.0以上 通过选择器输入数据 @param selectors 选择器 @param content 数据字符串 @return {boolean|布尔型} function main(){ var selectors= clz(\"android.widget.EditText\"); var result = inputText(selectors,\"我是内容\"); if (result){ toast(\"是\"); } else { toast(\"否\"); } } main(); imeInputText 使用输入法输入内容，前提是已经设置本程序的输入法为默认输入法 适合没有节点的情况，例如游戏等 @param selectors 选择器，可以为空，如果为空，前提是输入框是聚焦的状态 @param content 数据字符串 @return {boolean|布尔型} function main(){ var selectors= clz(\"android.widget.EditText\"); var result = imeInputText(selectors,\"我是内容\"); if (result){ toast(\"是\"); } else { toast(\"否\"); } } main(); imeInputKeyCode 使用输入法输入内容，前提是已经设置本程序的输入法为默认输入法 适合没有节点的情况，例如游戏等 @param selectors 选择器，可以为空，如果为空，前提是输入框是聚焦的状态 @param content 具体请看 KeyEvent.KEYCODE_*的值，例如66 = enter 67=del,84=SEARCH @return {boolean|布尔型} function main(){ var selectors= clz(\"android.widget.EditText\"); var result = imeInputKeyCode(selectors,66); if (result){ toast(\"是\"); } else { toast(\"否\"); } } main(); pasteText 执行条件：无障碍5.0以上 通过选择器粘贴数据 @param selectors 选择器 @param content 数据字符串 @return {boolean|布尔型} function main(){ var selectors= clz(\"android.widget.EditText\"); var result = pasteText(selectors,\"我是内容\"); if (result){ toast(\"是\"); } else { toast(\"否\"); } } main(); clearTextField 执行条件：无障碍5.0以上 @param selectors 节点选择器 @return {boolean|布尔型} function main(){ var selectors= clz(\"android.widget.EditText\"); var result = clearTextField(selectors); if (result){ toast(\"是\"); } else { toast(\"否\"); } } main(); 节点操作 has 通过选择器判断元素是否存在 @param selectors 选择器 @return {null|布尔型} function main(){ var selectors = text(\"设置\"); var result = has(selectors); if (result){ toast(\"存在节点\"); } else { toast(\"不存在节点\"); } } main(); waitExistActivity 等待activity界面出现 @param activity 界面名称 @param timeout 超时时间，单位毫秒 @return {null|布尔型} function main(){ var ac = \"com.xxx.MainActivity\"; var result = waitExistActivity(ac,10000); if (result){ toast(\"存在界面\"); } else { toast(\"不存在界面\"); } } main(); waitExistNode 通过选择器判断并等待元素是否存 @param selectors 选择器 @param timeout 超时时间，单位毫秒 @return {null|布尔型} function main(){ var selectors = text(\"设置\"); var result = waitExistNode(selectors,10000); if (result){ toast(\"存在节点\"); } else { toast(\"不存在节点\"); } } main(); getText 获取选择器得到的文本数据 @param selectors 选择器 @return {字符串数组|null|字符串集合} function main(){ var selectors = clz(\"android.widget.TextView\"); var result = getText(selectors); toast(\"result:\"+result); } main(); getNodeInfo 获取节点信息 @param selectors 选择器 @param timeout 等待时间，单位是毫秒 @return {null|NodeInfo数组|节点信息集合} function main(){ var result = clz(\"android.widget.TextView\").getNodeInfo(10*1000); toast(\"result:\"+result); } main(); getNodeAttrs 获取节点属性信息 @param selectors 选择器 @param attr 属性值,例如 text,className，更多的属性请参考NodeInfo对象属性 @return {null|字符串数组|Rect对象数组} function main(){ var selectors = clz(\"android.widget.TextView\"); //获取所有text属性 var result = getNodeAttrs(selectors,\"text\"); toast(\"result:\"+result); //获取所有bounds属性 result = getNodeAttrs(selectors,\"bounds\"); toast(\"result:\"+result); } main(); getOneNodeInfo 通过选择器 获取第一个节点信息 @param selectors 选择器 @param timeout 等待时间，单位是毫秒 @return NodeInfo 对象或者null function main(){ var result = clz(\"android.widget.TextView\").getOneNodeInfo(10*1000); toast(\"result:\"+result); if (result){ result.click(); } } main(); setFetchNodeMode 设置获取节点的模式 @param mode 1 是增强型， 2 是快速型，默认是增强型 @param fetchInvisibleNode 是否抓取隐藏的元素，默认不抓取 @param fetchNotImportantNode 是否抓取不重要的元素 @return {boolean|*} function main(){ var result = setFetchNodeMode(1,true,true); toast(\"result:\"+result); } main(); addNodeFlag 加上节点获取的某个标志位 @param flag 参见 AccessibilityServiceInfo.FLAG_*，如果是0是强制刷新 @return {null|boolean} function main(){ var result = addNodeFlag(0); toast(\"result:\"+result); } main(); removeNodeFlag 移除节点获取的某个标志位 @param flag 参见 AccessibilityServiceInfo.FLAG_*，如果是0是强制刷新 @return {null|boolean} function main(){ var result = removeNodeFlag(0); toast(\"result:\"+result); } main(); dumpXml 将元素节点变成XML @return string string|null function main(){ var result = dumpXml(); if (result){ toast(\"ok\"); } else { toast(\"no\"); } } main(); lockNode 锁定当前节点，锁定后，后面就算界面刷新，但是节点还是老的信息，需要和releaseNode进行配合才能进行解锁 function main(){ logd(\"锁住节点...\") //锁住节点，界面刷新也不动 lockNode(); for (var i = 0; i releaseNode 释放节点的锁，释放后，当界面刷新的时候，节点信息会变成最新的 function main(){ logd(\"锁住节点...\") //锁住节点，界面刷新也不动 lockNode(); for (var i = 0; i 系统按键相关 home 执行条件：无障碍5.0以上或者手势执行为代理服务 返回主页 @return {null|布尔型} function main(){ var result = home(); if (result){ toast(\"成功\"); } else { toast(\"失败\"); } } main(); power 执行条件：无障碍5.0以上或者手势执行为代理服务 模拟电源按键，无障碍是电源对话框，代理模式是电源键按下 @return {null|布尔型} function main(){ var result = power(); if (result){ toast(\"成功\"); } else { toast(\"失败\"); } } main(); back 执行条件：无障碍5.0以上或者手势执行为代理服务 返回键 @return {null|布尔型} function main(){ var result = back(); if (result){ toast(\"成功\"); } else { toast(\"失败\"); } } main(); openNotification 执行条件：无障碍5.0以上或者手势执行为代理服务 打开通知栏 @return {null|布尔型} function main(){ var result = openNotification(); if (result){ toast(\"成功\"); } else { toast(\"失败\"); } } main(); openQuickSettings 执行条件：无障碍5.0以上或者手势执行为代理服务 打开快速设置 @return {null|布尔型} function main(){ var result = openQuickSettings(); if (result){ toast(\"成功\"); } else { toast(\"失败\"); } } main(); recentApps 执行条件：无障碍5.0以上或者手势执行为代理服务 最近APP任务按键 @return {null|布尔型} function main(){ var result = recentApps(); if (result){ toast(\"成功\"); } else { toast(\"失败\"); } } main(); getRunningPkg 取得当前运行的App包名 @return {字符串|null} function main(){ var result = getRunningPkg(); } main(); getRunningActivity 取得当前运行的Activity类名 @return {字符串|null} function main(){ var result = getRunningActivity(); } main(); 通知栏 requestNotificationPermission 请求监听状态栏的权限 @param timeout 请求权限超时时间 单位是秒 @return true 代表请求权限成功，false代表失败 function main(){ var result = requestNotificationPermission(10); toast(\"是否有权限:\"+result); } main(); hasNotificationPermission 检查是否含有状态栏监听权限 @return true 代表请求权限成功，false代表失败 function main(){ var result = hasNotificationPermission(); toast(\"是否有权限:\"+result); } main(); getLastNotification 获取最近通知栏对象 @param pkg 指定包名 @param size 指定获取的条数 @return {NotificationInfo数组|null} function main(){ var result = getLastNotification(\"com.x\",100); toast(\"结果:\"+result); } main(); shotNotification 将通知发射处理，相当于点击了通知栏 @param seqId @return {boolean|布尔型} function main(){ var result = getLastNotification(\"com.x\",1); if (result!=null && result.length>0){ var s = shotNotification(result[0].seqId); toast(\"结果:\"+s); } } main(); ignoreNotification 忽略通知，从缓存队列移除，下次将不会获取 @param seqId @return {boolean|布尔型} function main(){ var result = getLastNotification(\"com.x\",1); if (result!=null && result.length>0){ var s = ignoreNotification(result[0].seqId); toast(\"结果:\"+s); } } main(); cancelNotification 将通知进行取消操作 @param seqId @return {boolean|布尔型} function main(){ var result = getLastNotification(\"com.x\",1); if (result!=null && result.length>0){ var s = cancelNotification(result[0].seqId); toast(\"结果:\"+s); } } main(); getLastToast 获取toast数据 @param pkg 指定包名 @param size 指定获取的条数 @return {null|ToastInfo数组} function main(){ var result = getLastToast(\"com.xx\",100); toast(\"结果:\"+result); } main(); 悬浮窗日志 requestFloatViewPermission 请求展示浮窗的权限 @param timeout 请求权限超时时间 单位是秒 @return true 代表请求权限成功，false代表失败 function main(){ var result = requestFloatViewPermission(10); toast(\"是否有权限:\"+result); } main(); hasFloatViewPermission 检查是否含有浮窗权限 @return true 代表请求权限成功，false代表失败 function main(){ var result = hasFloatViewPermission(); toast(\"是否有权限:\"+result); } main(); showFloatView 展示浮窗（如果是开发工具调试，请先预览一下工程，然后运行脚本，避免读取不到path文件内容的情况） @param params js的map对象，包含的 var map = {\"path\":\"main.html\",\"tag\":\"test\"}; 类似这样的参数 参数解析: tag:字符串 悬浮窗唯一定位的标示 path:字符串 IEC 中的布局文件 title:字符串 悬浮窗标题 titleBg:字符串 悬浮窗背景，16进制，例如#888888，或者#88000000 x:整型 悬浮窗起始X坐标 y:整型 悬浮窗起始Y坐标 w:整型 悬浮窗起始宽度 h:整型 悬浮窗起始高度 @return true 代表请求权限成功，false代表失败 function main(){ var m = { \"path\": \"main.html\", \"tag\": \"tag\", \"title\": \"sss\", \"titleBg\": \"#888888\", \"x\": 10, \"y\": 10, \"w\": 100, \"h\": 200 }; var xd = showFloatView(m); logd(\"showFloatView \" + xd); } main(); closeFloatView 关闭浮窗 @param tag showFloatView 使用的tag参数，对悬浮窗唯一定位的 @return true 成功，false代表失败 function main(){ var m = { \"path\": \"main.html\", \"tag\": \"tag\", \"title\": \"sss\", \"titleBg\": \"#888888\", \"x\": 10, \"y\": 10, \"w\": 100, \"h\": 200 }; var xd = showFloatView(m); logd(\"showFloatView \" + xd); sleep(3000); closeFloatView(\"tag\"); } main(); closeAllFloatView 关闭所有悬浮窗，但不包含日志悬浮窗 @return true 成功，false代表失败 function main(){ var m = { \"path\": \"main.html\", \"tag\": \"tag\", \"title\": \"sss\", \"titleBg\": \"#888888\", \"x\": 10, \"y\": 10, \"w\": 100, \"h\": 200 }; var xd = showFloatView(m); logd(\"showFloatView \" + xd); sleep(3000); closeAllFloatView(); } main(); showCtrlWindow 展示启停浮窗 @return true 代表请求权限成功，false代表失败 function main(){ var result = showCtrlWindow(); toast(\"是否展示:\"+result); } main(); closeCtrlWindow 关闭启停浮窗 @return true 代表请求权限成功，false代表失败 function main(){ var result = closeCtrlWindow(); toast(\"是否展示:\"+result); } main(); showLogWindow 展示日志浮窗 @return true 代表请求权限成功，false代表失败 function main(){ var result = showLogWindow(); toast(\"是否展示:\"+result); } main(); closeLogWindow 关闭日志浮窗 @return true 代表请求权限成功，false代表失败 function main(){ closeLogWindow(); } main(); setLogViewSizeEx 设置日志窗口大小扩展函数 @param map 例如 { \"x\":100, \"y\":100, \"w\":100, \"h\":200, \"textSize\":12, \"backgroundColor\":\"#ffffff\", \"title\":\"我是日志\", \"showTitle\":true } 解释： x: 起始X位置 y: 起始Y位置 w:宽度 h:高度 textSize:日志的字体大小 backgroundColor:背景颜色，例如#336699 title:日志框标题 showTitle：是否显示标题 @return bool true代表成功，false代表失败 function main() { requestFloatViewPermission(1000); var m = { \"x\":100, \"y\":200, \"w\":600, \"h\":600, \"textSize\":12, \"backgroundColor\":\"#ffffff\", \"title\":\"我是日222志\", \"showTitle\":false } showLogWindow(); setLogViewSizeEx(m); sleep(5000); } main(); setLogViewSize 设置日志窗口大小 @param w 宽度 @param h 高度 @param textSize 日志的字体大小 @param backgroundColor 背景颜色，例如#336699 function main(){ setLogViewSize(500,600,14,\"#FFFFFF\"); } main(); setLogText 展示消息到悬浮窗日志中，颜色是白色的 @param msg 消息 @param color 颜色值例如 #ffffff @param size 字体大小 function main(){ var result = setLogText(\"开始运行...\",\"#ffffff\",18); } main(); 定时任务 startJob 开启定时 开启一个定时脚本任务 @param tag 任务的唯一标示，不能为空，脚本中可以使用readConfigString(\"jobTaskTag\")获取当前tag值，判断是那个任务过来执行的 @param execTime 定时时间格式: 2020-04-17 19:20:00，或者直接是秒数字，例如 3，代表3秒后 @param cancelBeforeRunning @return 整型 jobid function main(){ var time=\"2020-04-17 09:00:00\"; //使用日期开启一个任务 var id =startJob(\"task1\",time,true); logd(\"job id \"+id); //使用秒数开启，60秒后执行一个任务 var id2 =startJob(\"task2\",\"60\",true); logd(\"job id \"+id2); } main(); cancelAllJob 取消所有定时 取消所有定时 @return bool true 代表有任务被取消 function main(){ var result = cancelAllJob(); logd(result); } main(); cancelJob 取消指定TAG定时 通过tag对定时任务进行取消 @param tag tag名称，startJob的时候tag参数的值 @return bool true 代表有任务被取消 function main(){ var result = cancelJob(\"task1\"); logd(result); } main(); getAllJobTag 获取所有定时标签 取得所有的定时任务标签 @return 字符串数组或者null function main(){ var result = getAllJobTag(); logd(result); } main(); 其他函数 random 随机函数 取得某个范围的随机值 @param min 最小值 @param max 最大值 @return 整型 在min和max中间的值, 包含最大和最小值 function main(){ var result = random(100,1000); sleep(result); } main(); "},"zh-cn/funcs/global/selector-node.html":{"url":"zh-cn/funcs/global/selector-node.html","title":"选择器&节点","keywords":"","body":"说明 这个章节主要讲解选择器类使用和节点信息类 选择器对象 选择器对象是支持级联选择，可以在无法直接选择到元素的时候，先通过选择父级后再选择子级 选择器部分支撑正则匹配，请参考java的正则语法，教程 text属性选择 全文本匹配 function main(){ //获取选择器对象 var selector = text(\"设置\"); click(selector); } main(); 正则匹配 function main(){ //获取选择器对象 var selector = textMatch(\".*设置.*\"); var result = click(selector); if (result) { toast(\"点击成功\"); } else { toast(\"点击失败\"); } } main(); id 属性选择 全量匹配 function main(){ //获取选择器对象 var selector = id(\"com.xx:id/a1\"); var result = click(selector); if (result) { toast(\"点击成功\"); } else { toast(\"点击失败\"); } } main(); 正则匹配 function main(){ //获取选择器对象 var selector = idMatch(\".*id8.*\"); var result = click(selector); if (result) { toast(\"点击成功\"); } else { toast(\"点击失败\"); } } main(); clz 属性选择 全量匹配 function main(){ //获取选择器对象 var selector = clz(\"android.widget.TextView\"); var result = click(selector); if (result) { toast(\"点击成功\"); } else { toast(\"点击失败\"); } } main(); 正则匹配 function main(){ //获取选择器对象 var selector = clzMatch(\".*TextView.*\"); var result = click(selector); if (result) { toast(\"点击成功\"); } else { toast(\"点击失败\"); } } main(); pkg 属性选择 全量匹配 function main(){ //获取选择器对象 var selector = pkg(\"com.xx\"); var result = click(selector); if (result) { toast(\"点击成功\"); } else { toast(\"点击失败\"); } } main(); 正则匹配 function main(){ //获取选择器对象 var selector = pkgMatch(\".*tencent.*\"); var result = click(selector); if (result) { toast(\"点击成功\"); } else { toast(\"点击失败\"); } } main(); desc 文本属性选择 全量匹配 function main(){ //获取选择器对象 var selector = desc(\"我是描述\"); var result = click(selector); if (result) { toast(\"点击成功\"); } else { toast(\"点击失败\"); } } main(); 正则匹配 function main(){ //获取选择器对象 var selector = descMatch(\".*描述.*\"); var result = click(selector); if (result) { toast(\"点击成功\"); } else { toast(\"点击失败\"); } } main() 深度和绘制顺序匹配 drawingOrder function main(){ //获取选择器对象 var selector = drawingOrder(1); var result = click(selector); if (result) { toast(\"点击成功\"); } else { toast(\"点击失败\"); } } main(); depth function main(){ //获取选择器对象 var selector = depth(1); var result = click(selector); if (result) { toast(\"点击成功\"); } else { toast(\"点击失败\"); } } main(); 其他匹配规则 visible 可视化属性匹配 按照属性 visible 进行匹配 @param value 字符串 @return {S} 节点选择器 function main(){ var node = visible(true).getOneNodeInfo(1000); logd(\"node \"+node); } main(); bounds 范围匹配 按照属性 bounds 进行范围 * @param left 范围左边数值 @param top 范围上边数值 @param right 范围右边数值 @param bottom 范围底边数值 @return {S} 节点选择器 function main(){ //获取选择器对象 0 - 800以内范围内的控件 var selector = bounds(0,0,800,800); var result = click(selector); if (result) { toast(\"点击成功\"); } else { toast(\"点击失败\"); } } main(); checkable function main(){ //获取选择器对象 var selector = checkable(true); var result = click(selector); if (result) { toast(\"点击成功\"); } else { toast(\"点击失败\"); } } main(); checked function main(){ //获取选择器对象 var selector = checked(true); var result = click(selector); if (result) { toast(\"点击成功\"); } else { toast(\"点击失败\"); } } main(); clickable function main(){ //获取选择器对象 var selector = clickable(true); var result = click(selector); if (result) { toast(\"点击成功\"); } else { toast(\"点击失败\"); } } main(); longClickable function main(){ //获取选择器对象 var selector = longClickable(true); var result = click(selector); if (result) { toast(\"点击成功\"); } else { toast(\"点击失败\"); } } main(); scrollable function main(){ //获取选择器对象 var selector = scrollable(true); var result = click(selector); if (result) { toast(\"点击成功\"); } else { toast(\"点击失败\"); } } main(); focusable function main(){ //获取选择器对象 var selector = focusable(true); var result = click(selector); if (result) { toast(\"点击成功\"); } else { toast(\"点击失败\"); } } main(); enabled function main(){ //获取选择器对象 var selector = enabled(true); var result = click(selector); if (result) { toast(\"点击成功\"); } else { toast(\"点击失败\"); } } main(); focused function main(){ //获取选择器对象 var selector = focused(true); var result = click(selector); if (result) { toast(\"点击成功\"); } else { toast(\"点击失败\"); } } main(); selected function main(){ //获取选择器对象 var selector = selected(true); var result = click(selector); if (result) { toast(\"点击成功\"); } else { toast(\"点击失败\"); } } main(); index function main(){ //获取选择器对象 var selector = index(1); var result = click(selector); if (result) { toast(\"点击成功\"); } else { toast(\"点击失败\"); } } main(); childCount function main(){ //获取选择器对象 var selector = childCount(1); var result = click(selector); if (result) { toast(\"点击成功\"); } else { toast(\"点击失败\"); } } main(); 级联匹配 function main(){ //获取选择器对象 //选择 父级为android.widget.ScrollView下的子节点clz=android.widget.CheckBox所有节点 var selector = clz(\"android.widget.ScrollView\") .child() .clz(\"android.widget.CheckBox\"); var result = click(selector); if (result) { toast(\"点击成功\"); } else { toast(\"点击失败\"); } } main(); 多属性匹配 function main(){ //获取选择器对象， //选择包含\"选择器\"并且checked=true并且类名=android.widget.CheckBox的元素 var selector = text(\".*选择器.*\") .checked(true) .clz(\"android.widget.CheckBox\"); var result = click(selector); if (result) { toast(\"点击成功\"); } else { toast(\"点击失败\"); } } main(); 节点信息类 节点对象NodeInfo，可以通过获取getNodeInfo方法获取到节点信息的数组,节点包含的信息如下 id: 字符串，资源的ID clz: 字符串，视图类名，例如 android.widget.TextView pkg: 字符串，包名，例如com.xx desc: 字符串，内容描述 text: 字符串，文本 checkable: 布尔型，是否可选中 checked: 布尔型，是否选中 clickable: 布尔型，是否可点击 enabled: 布尔型，是否启用 focusable: 布尔型，是否可获取焦点 focused: 布尔型，是否聚焦 longClickable: 布尔型，是否可长点击 scrollable: 布尔型，是否滚动 selected: 布尔型，是否被选择 childCount: 整型，子节点的个数 index: 整型 节点的索引 depth: 整型 节点的层级深度 drawingOrder: 整型 节点的绘制顺序 bounds: Rect型，空间对象 top: 整型，顶部位置 bottom: 整型，底部位置 left: 整型，左边位置 right: 整型，右边位置 visibleBounds: Rect型，可视空间对象 top: 整型，顶部位置 bottom: 整型，底部位置 left: 整型，左边位置 right: 整型，右边位置 选择器获取一个节点 getOneNodeInfo 通过选择器 获取第一个节点信息 @param timeout 等待时间，单位是毫秒, 如果是0，代表不等待 @return NodeInfo 对象 或者null function main(){ //获取选择器对象 //选择 节点 clz=android.widget.CheckBox所有节点， var node = clz(\"android.widget.CheckBox\").getOneNodeInfo(10000); if (node) { var x= node.click(); logd(x); } else { toast(\"无节点\"); } } main(); 选择器获取多个节点 getNodeInfo 获取节点信息 @param timeout 等待时间，单位是毫秒, 如果是0，代表不等待 @return NodeInfo 节点信息集合 function main(){ //获取选择器对象 //选择 节点 clz=android.widget.CheckBox所有节点， var node = clz(\"android.widget.CheckBox\").getNodeInfo(10000); logd(node); } main(); 级联获取一个子节点操作 getOneNodeInfo 通过选择器 获取第一个节点信息 @param timeout 等待时间，单位是毫秒, 如果是0，代表不等待 @return NodeInfo 对象 或者null function main(){ //获取选择器对象 //选择 节点 clz=android.widget.ViewGroup 所有节点， var node = clz(\"android.widget.ViewGroup\").getOneNodeInfo(10000); if (node) { //获取子节点 node =node.getOneNodeInfo(text(\"广告\"),10000); if (!node){ toast(\"无子节点\"); return; } var x= node.click(); logd(x); } else { toast(\"无节点\"); } } main(); 级联获取多个子节点操作 getNodeInfo 获取节点信息 @param timeout 等待时间，单位是毫秒, 如果是0，代表不等待 @return NodeInfo 节点信息集合 function main(){ //获取选择器对象 //选择 节点 clz=android.widget.ViewGroup 所有节点， var node = clz(\"android.widget.ViewGroup\").getNodeInfo(10000); if (node) { //获取子节点 node =node.getNodeInfo(text(\"广告\").clz(\"android.widget.TextView\"),10000); if (!node){ toast(\"无子节点\"); return; } var x= node.click(); logd(x); } else { toast(\"无节点\"); } } main(); 获取父节点 parent 该节点的父级节点 @return NodeInfo 对象 或者null function main(){ //获取选择器对象 //选择 节点 clz=android.widget.CheckBox所有节点 var node = clz(\"android.widget.CheckBox\").getOneNodeInfo(10000); if (node) { var x= node.parent(); logd(x); } else { toast(\"无节点\"); } } main(); 获取子节点 child 取得单个子节点 @param index 子节点索引 @return NodeInfo 对象 或者null function main(){ //选择 节点 clz=android.widget.ViewGroup 所有节点 var node = clz(\"android.widget.ViewGroup\").getOneNodeInfo(10000); if (node) { var x= node.child(0); logd(x); } else { toast(\"无节点\"); } } main(); 获取所有子节点 allChildren 获取所有子节点 @return NodeInfo 节点集合 function main(){ //选择 节点 clz=android.widget.ViewGroup 所有节点 var node = clz(\"android.widget.ViewGroup\").getOneNodeInfo(10000); if (node) { var x= node.allChildren(); logd(x); } else { toast(\"无节点\"); } } main(); 所有兄弟节点 siblings 当前节点的所有兄弟节点 @return NodeInfo 节点集合 function main(){ //选择 节点 clz=android.widget.ViewGroup 所有节点 var node = clz(\"android.widget.ViewGroup\").getOneNodeInfo(10000); if (node) { var x= node.siblings(); logd(x); } else { toast(\"无节点\"); } } main(); 前面的兄弟节点 previousSiblings 在当前节点前面的兄弟节点 @return NodeInfo 节点集合 function main(){ //选择 节点 clz=android.widget.ViewGroup 所有节点 var node = clz(\"android.widget.ViewGroup\").getOneNodeInfo(10000); if (node!=null) { var x= node.previousSiblings(); logd(x); } else { toast(\"无节点\"); } } main(); 后面的兄弟节点 nextSiblings 在当前节点后面的兄弟节点 @return NodeInfo 节点集合 function main(){ //选择 节点 clz=android.widget.ViewGroup 所有节点 var node = clz(\"android.widget.ViewGroup\").getOneNodeInfo(10000); if (node) { var x= node.nextSiblings(); logd(x); } else { toast(\"无节点\"); } } main(); 节点区域随机点击 click 执行条件：无障碍7.0以上或者手势执行为代理服务 点击节点 @return bool, true 成功 ,false 失败 function main(){ //获取选择器对象 //选择 节点 clz=android.widget.CheckBox所有节点 var node = clz(\"android.widget.CheckBox\").getOneNodeInfo(10000); if (node) { node.click() } else { toast(\"无节点\"); } } main(); 无指针点击 clickEx 执行条件：无障碍5.0以上或者手势执行为代理服务 无指针方式点击选择器，节点必须是可点击的才行 @param selectors 选择器对象 @return {boolean|布尔型} function main(){ var node = text(\"我是文本\").getOneNodeInfo(10000); var result = node.clickEx(); if (result){ toast(\"点击成功\"); } else { toast(\"点击失败\"); } } main(); 无指针长点击 longClickEx 执行条件：无障碍5.0以上或者手势执行为代理服务 无指针方式长点击选择器，节点必须是可点击的才行 @param selectors 选择器对象 @return {boolean|布尔型} function main(){ var node = text(\"我是文本\").getOneNodeInfo(10000); var result = node.longClickEx(); if (result){ toast(\"点击成功\"); } else { toast(\"点击失败\"); } } main(); 节点点击中心点 clickCenter 执行条件：无障碍7.0以上或者手势执行为代理服务 节点点击中心点 @return bool, true 成功 ,false 失败 function main(){ //获取选择器对象 //选择 节点 clz=android.widget.CheckBox所有节点 var node = clz(\"android.widget.CheckBox\").getOneNodeInfo(10000); if (node) { node.clickCenter(); } else { toast(\"无节点\"); } } main(); 节点长点击 longClick 执行条件：无障碍7.0以上或者手势执行为代理服务 长点击节点 @return bool, true 成功 ,false 失败 function main(){ //获取选择器对象 //选择 节点 clz=android.widget.CheckBox所有节点 var node = clz(\"android.widget.CheckBox\").getOneNodeInfo(10000); if (node) { node.longClick() } else { toast(\"无节点\"); } } main(); 节点输入 inputText 执行条件：无障碍5.0以上或者手势执行为代理服务 对某个节点输入数据 @param content 要输入的内容 @return bool, true 成功 ,false 失败 function main(){ //获取选择器对象 //选择 节点 clz=android.widget.EditText 所有节点 var node = clz(\"android.widget.EditText\").getOneNodeInfo(10000); if (node) { node.inputText(\"内容\") } else { toast(\"无节点\"); } } main(); 节点输入法输入 imeInputText 执行条件：无障碍5.0以上或者手势执行为代理服务 使用输入法对某个节点输入数据，前提是已经设置本程序的输入法为默认输入法 @param content 要输入的内容 @return bool, true 成功 ,false 失败 function main(){ //获取选择器对象 //选择 节点 clz=android.widget.EditText 所有节点 var node = clz(\"android.widget.EditText\").getOneNodeInfo(10000); if (node) { node.imeInputText(\"内容\") } else { toast(\"无节点\"); } } main(); imeInputKeyCode 使用输入法输入内容，前提是已经设置本程序的输入法为默认输入法 适合没有节点的情况，例如游戏等 @param selectors 选择器，可以为空，如果为空，前提是输入框是聚焦的状态 @param content 具体请看 KeyEvent.KEYCODE_*的值，例如66 = enter 67=del,84=SEARCH @return {boolean|布尔型} function main(){ var result = clz(\"android.widget.EditText\").imeInputKeyCode(66); if (result){ toast(\"是\"); } else { toast(\"否\"); } } main(); 节点数据清除 clearText 执行条件：无障碍5.0以上或者手势执行为代理服务 清除节点文本数据 function main(){ //获取选择器对象 //选择 节点 clz=android.widget.EditText 所有节点 var node = clz(\"android.widget.EditText\").getOneNodeInfo(); if (node) { var r =node.clearText(); logd(\"r -=> \"+r); } else { toast(\"无节点\"); } } main(); 节点刷新 refresh 该方法会刷新节点缓存 function main(){ //获取选择器对象 //选择 节点 clz=android.widget.EditText 所有节点 var node = clz(\"android.widget.EditText\").getOneNodeInfo(10000); if (node) { node.refresh(); } else { toast(\"无节点\"); } } main(); 节点有效判断 isValid 节点信息是否有效 @return bool|布尔型 true代表有 function main(){ //获取选择器对象 //选择 节点 clz=android.widget.EditText 所有节点 var node = clz(\"android.widget.EditText\").getOneNodeInfo(10000); if (node) { var x =node.isValid(); toast(\"节点有效性:\"+x); } else { toast(\"无节点\"); } } main(); 向前滚动 scrollForward 执行条件：无障碍5.0以上或者手势执行为代理服务 向前滚动 @param selectors 选择器对象 @return {boolean|布尔型} function main(){ var node = scrollable(true).getOneNodeInfo(10000); var result = node.scrollForward(); if (result){ toast(\"滚动成功\"); } else { toast(\"滚动失败\"); } } main(); 向后滚动 scrollBackward 执行条件：无障碍5.0以上或者手势执行为代理服务 向后滚动 @param selectors 选择器对象 @return {boolean|布尔型} function main(){ var node = scrollable(true).getOneNodeInfo(10000); var result = node.scrollBackward(); if (result){ toast(\"滚动成功\"); } else { toast(\"滚动失败\"); } } main(); "},"zh-cn/funcs/acevent-api.html":{"url":"zh-cn/funcs/acevent-api.html","title":"无障碍事件","keywords":"","body":"说明 无障碍模式需要打开无障碍服务，如果使用电脑激活过，会自动打开无障碍服务哦！ 提示：7.0及以上版本，全局函数是都支持的，如果是7.0一下版本使用无障碍，请使用专门标5.0以上支持的函数 无障碍模式下，API限制较多，无法全部达到代理模式下的功能 函数调用请看全局函数 "},"zh-cn/funcs/event-api.html":{"url":"zh-cn/funcs/event-api.html","title":"代理事件","keywords":"","body":"说明 代理事件模块运行的所有函数，是需要使用电脑激活才能使用的，免root 代理事件模块的对象前缀是agentEvent，例如 agentEvent.clickPoint这样调用 这里列出来的是代理模式特有的函数，其他调用可以直接使用全局函数 输入数据 setCurrentIme 设置当前的输入法，用于输入数据 @return {boolean|布尔型} function main(){ var result = agentEvent.setCurrentIme(); if (result){ toast(\"是\"); }else { toast(\"否\"); } } main(); restoreIme 恢复到之前的输入法 @return {boolean|布尔型} function main(){ var result = agentEvent.restoreIme(); if (result){ toast(\"是\"); }else { toast(\"否\"); } } main(); 截图 fastScreenshot 快速截屏幕的截图 @param filename 文件路径 @return 字符串 截图的路径 function main(){ var result = agentEvent.fastScreenshot(\"/sdcard/a.jpg\"); toast(\"result:\"+result); } main(); 手势及输入事件 inputEvent 执行输入事件 @param action 动作，请看类: MotionEvent.ACTION_* @param x x坐标 @param y y坐标 @param metaState 控制按键，比如说shift键，alt键，ctrl键等控制键, 0或者 1 any meta info @return 布尔型 true 代表成功 false代表失败 function main(){ var result = agentEvent.inputEvent(1,10,10,0); if (result){ toast(\"成功\"); }else { toast(\"失败\"); } } main(); touchDown 执行按下输入事件 @param x x坐标 @param y y坐标 @return 布尔型 true 代表成功 false代表失败 function main(){ var result = agentEvent.touchDown(10,10); if (result){ toast(\"成功\"); }else { toast(\"失败\"); } } main(); touchMove 执行移动输入事件 @param x x坐标 @param y y坐标 @return 布尔型 true 代表成功 false代表失败 function main(){ var result = agentEvent.touchMove(10,10); if (result){ toast(\"成功\"); }else { toast(\"失败\"); } } main(); touchUp 执行弹起输入事件 @param x x坐标 @param y y坐标 @return 布尔型 true 代表成功 false代表失败 function main(){ var result = agentEvent.touchUp(10,10); if (result){ toast(\"成功\"); }else { toast(\"失败\"); } } main(); multiTouch 多点触摸 多点触摸 触摸参数: action :一般情况下 按下为0，弹起为1，移动为2 x: X坐标 y: Y坐标 pointer：设置第几个手指触摸点，分别是 1，2，3等，代表第n个手指 delay: 该动作延迟多少毫秒执行 @param touch1 第1个手指的触摸点数组,例如：[{\"action\":0,\"x\":1,\"y\":1,\"pointer\":1,\"delay\":20},{\"action\":2,\"x\":1,\"y\":1,\"pointer\":1,\"delay\":20}] @param touch2 第2个手指的触摸点数组 @param touch3 第3个手指的触摸点数组 @param timeout 多点触摸执行的超时时间，单位是毫秒 @return boolean|布尔型 function main() { utils.openAppByName(\"视频\"); sleep(3000); //第一种数组式的写法 var touch1 = [ {\"action\": 0, \"x\": 500, \"y\": 1200, \"pointer\": 1, \"delay\": 1}, { \"action\": 2, \"x\": 500, \"y\": 1100, \"pointer\": 1, \"delay\": 20 }, { \"action\": 2, \"x\": 500, \"y\": 1000, \"pointer\": 1, \"delay\": 20 }, { \"action\": 1, \"x\": 1, \"y\": 1, \"pointer\": 1, \"delay\": 20 }]; //第二种链式调用方法 var touch1 = MultiPoint .get() .action(0).x(500).y(1200).pointer(1).delay(1) .next() .action(2).x(500).y(1100).pointer(1).delay(1) .next() .action(2).x(500).y(1000).pointer(1).delay(1) .next() .action(2).x(500).y(900).pointer(1).delay(1) .next() .action(1).x(500).y(800).pointer(1).delay(1); var touch2 = MultiPoint .get() .action(0).x(300).y(1200).pointer(2).delay(1) .next() .action(2).x(300).y(1100).pointer(2).delay(1) .next() .action(2).x(300).y(1000).pointer(2).delay(1) .next() .action(2).x(300).y(900).pointer(2).delay(1) .next() .action(1).x(300).y(800).pointer(2).delay(1); var x = agentEvent.multiTouch(touch1, touch2, null, 30000); logd(\"xxs \" + x); } main(); pressKey 模拟按键,例如home back等 @param key 对应的值分别为 home, back, left, right, up, down, center, menu, search, enter, delete(or del), recent(recent apps), volume_up, volume_down, volume_mute, camera, power @return 布尔型 true 成功, false 失败 function main(){ var result = agentEvent.pressKey(\"home\"); if (result){ toast(\"成功\"); }else { toast(\"失败\"); } } main(); pressKeyCode 模拟键盘输入 @param keyCode 键盘的key，参见KeyEvent.KEYCODE_* @return 布尔型 true 代表成功，false 代表失败 function main(){ var result = agentEvent.pressKeyCode(65); if (result){ toast(\"成功\"); }else { toast(\"失败\"); } } main(); pressKeyCodeWithMetaState 模拟键盘输入 @param keyCode keyCode 键盘的key，参见KeyEvent.KEYCODE_* @param metaState metaState 控制按键，比如说shift键，alt键，ctrl键等控制键, 0或者 1 @return 布尔型 true 代表成功，false 代表失败。 function main(){ var result = agentEvent.pressKeyCodeWithMetaState(65,1); if (result){ toast(\"成功\"); }else { toast(\"失败\"); } } main(); 系统按键相关 menu 打开菜单 @return {null|布尔型} function main(){ var result = agentEvent.menu(); if (result){ toast(\"成功\"); }else { toast(\"失败\"); } } main(); enter Enter键 @return {null|布尔型} var result = agentEvent.enter(); if (result){ toast(\"成功\"); }else { toast(\"失败\"); } } main(); ``` delete 删除键 @return {null|布尔型} function main(){ var result = agentEvent.delete(); if (result){ toast(\"成功\"); }else { toast(\"失败\"); } } main(); search 搜索 @return {null|布尔型} function main(){ var result = agentEvent.search(); if (result){ toast(\"成功\"); }else { toast(\"失败\"); } } main(); 屏幕控制 closeScreen 关闭屏幕，屏幕不亮，但是依然可以自动点击，不同于sleepScreen @return 布尔型 true 成功，false 失败 function main(){ var x =agentEvent.closeScreen(); } main(); lightScreen 点亮屏幕，和closeScreen相反的动作 @return 布尔型 true 成功，false 失败 function main(){ var x =agentEvent.lightScreen(); } main(); "},"zh-cn/funcs/image-api.html":{"url":"zh-cn/funcs/image-api.html","title":"图色函数","keywords":"","body":"说明 截图函数需要Andrioid 5.0 以上版本才能使用 无障碍模式下截图是需要权限的，如果弹出了运行截图，请授权 代理模式下的截图不需要权限，建议长期运行使用代理模式 图色模块的对象前缀是image，例如 image.requestScreenCapture()这样调用 图色模块需要对颜色进行查找，开发工具自带找色功能，请参考找色找图操作 设置 image.setInitParam 设置图色模块初始化参数，可用于多分辨率兼容 @param params 超时时间，单位是毫秒 @return true 代表成功 false代表失败 function main() { //action_timeout 找图找色动作的最大时间，超时后会自动返回避免阻塞 var a = image.setInitParam({\"action_timeout\":1000}); } main(); 申请截图 image.requestScreenCapture 向系统申请屏幕截图权限，返回是否请求成功。 第一次使用该函数会弹出截图权限请求，建议选择“总是允许”。 这个函数只是申请截图权限，并不会真正执行截图，真正的截图函数是captureScreen()。 该函数在截图脚本中只需执行一次，而无需每次调用captureScreen()都调用一次。 @param timeout 超时时间，单位是毫秒 @param type 截屏的类型，0 自动选择，1 代表授权模式，2 代表无需权限模式（该模式前提条件：运行模式为代理模式） @return true 代表成功 false代表失败 function main() { logd(\"isServiceOk \"+isServiceOk()); startEnv() logd(\"isServiceOk \"+isServiceOk()); var request = image.requestScreenCapture(10000,0); if (!request) { request = image.requestScreenCapture(10000,0); } logd(\"申请截图结果... \"+request) } main(); image.releaseScreenCapture 释放截屏请求 function main() { image.releaseScreenCapture(); } main(); 截图 image.captureScreen 截取当前屏幕并返回一个Image对象。 没有截图权限时执行该函数会返回null 两次调用可能返回相同的Image对象。这是因为设备截图的更新需要一定的时间，短时间内（一般来说是16ms）连续调用则会返回同一张截图。 截图需要转换为Bitmap格式，从而该函数执行需要一定的时间(0~20ms)。 另外在requestScreenCapture()执行成功后需要一定时间后才有截图可用，因此如果立即调用captureScreen()，会等待一定时间后(一般为几百ms)才返回截图。 如果区域空或则有负数的，就会是全屏 @param retryNumber 重试次数，直到能截到图为止，默认是3 @param x 截图的起始X坐标 @param y 截图的起始Y坐标 @param ex 终点X坐标 @param ey 终点Y坐标 @return AutoImage对象或者null function main() { logd(\"isServiceOk \"+isServiceOk()); startEnv() logd(\"isServiceOk \"+isServiceOk()); var request = image.requestScreenCapture(10000,0); if (!request) { request = image.requestScreenCapture(10000,0); } logd(\"申请截图结果... \"+request) if (!request) { return; } home(); sleep(1000); for (var i = 0; i image.captureFullScreen 截取当前屏幕并返回一个Image对象。 @return AutoImage对象或者null function main() { logd(\"isServiceOk \"+isServiceOk()); startEnv() logd(\"isServiceOk \"+isServiceOk()); var request = image.requestScreenCapture(10000,0); if (!request) { request = image.requestScreenCapture(10000,0); } logd(\"申请截图结果... \"+request) if (!request) { return; } home(); sleep(1000); for (var i = 0; i image.captureFullScreenEx 抓取全屏函数，代理模式下并且requestScreenCapture函数的type为0的时候，会使用截屏函数，尽力消除色差问题。 @return AutoImage对象或者null function main() { logd(\"isServiceOk \"+isServiceOk()); startEnv() logd(\"isServiceOk \"+isServiceOk()); var request = image.requestScreenCapture(10000,0); if (!request) { request = image.requestScreenCapture(10000,0); } logd(\"申请截图结果... \"+request) if (!request) { return; } home(); sleep(1000); for (var i = 0; i image.captureScreenBitmap 将屏幕抓取为Bitmap对象，如果中间有-1或者宽度、宽度为-1，将会是全屏 @param format jpg或者png，代理模式下有用 @param x 开始X坐标 @param y 开始Y坐标 @param ex 终点X坐标 @param ey 终点Y坐标 @param q 图片质量，1 - 100，越高越好，代理模式下有用 @return Bitmap null或者bitmap对象 function main() { logd(\"isServiceOk \"+isServiceOk()); startEnv() logd(\"isServiceOk \"+isServiceOk()); var request = image.requestScreenCapture(10000,0); if (!request) { request = image.requestScreenCapture(10000,0); } logd(\"申请截图结果... \"+request) if (!request) { return; } home(); sleep(1000); for (var i = 0; i image.captureToFile 截取当前屏幕并以PNG格式保存到path中。如果文件不存在会被创建；文件存在会被覆盖。 如果区域空或则有负数的，就会是全屏 @param retryNumber 重试次数，直到能截到图为止，默认是3 @param x 截图的起始X坐标 @param y 截图的起始Y坐标 @param ex 终点X坐标 @param ey 终点Y坐标 @param path 截图保存路径 @return true 截图成功 false 代表不成功 function main() { logd(\"isServiceOk \"+isServiceOk()); startEnv() logd(\"isServiceOk \"+isServiceOk()); var request = image.requestScreenCapture(10000,0); if (!request) { request = image.requestScreenCapture(10000,0); } logd(\"申请截图结果... \"+request) if (!request) { return; } home(); sleep(1000); for (var i = 0; i 比色 image.cmpColor 单点或者多点比色，找到所有符合标准的点，如果都符合返回true，否则是false @param image1 图片 @param points 字符串类似这样 6|1|0x969696-0x000010,1|12|0x969696,-4|0|0x969696 @param threshold 找色时颜色相似度取值为 0.0 ~ 1.0 @param x 区域的X起始坐标，默认填写0全屏查找 @param y 区域的Y起始坐标，默认填写0全屏查找 @param ex 终点X坐标，默认填写0全屏查找 @param ey 终点Y坐标，默认填写0全屏查找 @return 布尔型，true代表找到了 false代表未找到 function main() { var req = image.requestScreenCapture(10000,0); if (!req) { req = image.requestScreenCapture(10000,0); } if (!req) { toast(\"申请权限失败\"); return; } var aimage = image.captureFullScreen(); if (aimage != null) { var points3 =\"205|1130|0xff944b-0x101010,211|1158|0xff8e42,191|1175|0xfcfbf7\"; var points = image.cmpColor(aimage,points3, 0.9, 0, 0, 0, 0); logd(\"points \"+points); } } main(); image.cmpColorEx 单点或者多点比色，找到所有符合标准的点，自动截图，如果都符合返回true，否则是false @param points 字符串类似这样 6|1|0x969696-0x000010,1|12|0x969696,-4|0|0x969696 @param threshold 找色时颜色相似度取值为 0.0 ~ 1.0 @param x 区域的X起始坐标，默认填写0全屏查找 @param y 区域的Y起始坐标，默认填写0全屏查找 @param ex 终点X坐标，默认填写0全屏查找 @param ey 终点Y坐标，默认填写0全屏查找 @return 布尔型，true代表找到了 false代表未找到 function main() { var req = image.requestScreenCapture(10000,0); if (!req) { req = image.requestScreenCapture(10000,0); } if (!req) { toast(\"申请权限失败\"); return; } var points3 =\"205|1130|0xff944b-0x101010,211|1158|0xff8e42,191|1175|0xfcfbf7\"; var points = image.cmpColorEx(points3, 0.9, 0, 0, 0, 0); logd(\"points \"+points); } main(); image.cmpMultiColor 多点或者多点数组比色，找到所有符合标准的点，依次查找，如果找到就返回当前points的索引值，如果返回-1，说明都没有找到 @param image1 图片 @param points 数组类似这样 [\"6|1|0x969696-0x000010,1|12|0x969696,-4|0|0x969696\",\"6|1|0x969696\"] @param threshold 找色时颜色相似度取值为 0.0 ~ 1.0 @param x 区域的X起始坐标，默认填写0全屏查找 @param y 区域的Y起始坐标，默认填写0全屏查找 @param ex 终点X坐标，默认填写0全屏查找 @param ey 终点Y坐标，默认填写0全屏查找 @return 整型，如果找到就返回当前points的索引值，如果返回-1，说明都没有找到 function main() { var req = image.requestScreenCapture(10000,0); if (!req) { req = image.requestScreenCapture(10000,0); } if (!req) { toast(\"申请权限失败\"); return; } var aimage = image.captureFullScreen(); if (aimage != null) { var points1 =\"205|112230|0xff944b,211|1158|0xff8e42,191|1175|0xfcfbf7\"; var points2 =\"205|113022|0xff944b,211|1158|0xff8e42,191|1175|0xfcfbf7\"; var points3 =\"205|1130|0xff944b,211|1158|0xff8e42,191|1175|0xfcfbf7\"; var points = image.cmpMultiColor(aimage,[points1,points2,points3], 0.9, 0, 0, 0, 0); logd(\"points \"+points); } } main(); image.cmpMultiColorEx 多点或者多点数组比色，找到所有符合标准的点，自动截屏，依次查找，如果找到就返回当前points的索引值，如果返回-1，说明都没有找到 @param points 数组类似这样 [\"6|1|0x969696-0x000010,1|12|0x969696,-4|0|0x969696\",\"6|1|0x969696\"] @param threshold 找色时颜色相似度取值为 0.0 ~ 1.0 @param x 区域的X起始坐标，默认填写0全屏查找 @param y 区域的Y起始坐标，默认填写0全屏查找 @param ex 终点X坐标，默认填写0全屏查找 @param ey 终点Y坐标，默认填写0全屏查找 @return 整型，如果找到就返回当前points的索引值，如果返回-1，说明都没有找到 function main() { var req = image.requestScreenCapture(10000,0); if (!req) { req = image.requestScreenCapture(10000,0); } if (!req) { toast(\"申请权限失败\"); return; } var points1 =\"205|112230|0xff944b,211|1158|0xff8e42,191|1175|0xfcfbf7\"; var points2 =\"205|113022|0xff944b,211|1158|0xff8e42,191|1175|0xfcfbf7\"; var points3 =\"205|1130|0xff944b,211|1158|0xff8e42,191|1175|0xfcfbf7\"; var points = image.cmpMultiColorEx([points1,points2,points3], 0.9, 0, 0, 0, 0); logd(\"points \"+points); } main(); 找色 image.findColor 在图片中找到颜色和color完全相等的某个点，并返回该点的左边；如果没有找到，则返回null。 @param image 图片 @param color 要寻找的颜色 @param threshold 找色时颜色相似度取值为 0.0 ~ 1.0 @param x 区域的X起始坐标 @param y 区域的Y起始坐标 @param ex 终点X坐标 @param ey 终点Y坐标 @param limit 限制个数 @param orz 方向，分别从1-8 @return 多个Point 坐标点数组或者null function main() { var req = image.requestScreenCapture(10000,0); if (!req) { req = image.requestScreenCapture(10000,0); } if (!req) { toast(\"申请权限失败\"); return; } var aimage = image.captureFullScreen(); if (aimage != null) { var points = image.findColor(aimage,\"0xCDD7E9-0x101010\", 0.9, 0, 0, 0, 0, 10,1); logd(\"points \"+points); } } main(); image.findColorJ 在图片中找到颜色和color完全相等的点，参数从JSON中获取如果没有找到，则返回null。 @param image 图片 @param jsonFileName res文件中取色工具生成的JSON文件，只要填写文件名称即可，后缀不用填写 @return 多个Point 坐标点数组或者null function main() { var req = image.requestScreenCapture(10000,0); if (!req) { req = image.requestScreenCapture(10000,0); } if (!req) { toast(\"申请权限失败\"); return; } var aimage = image.captureFullScreen(); if (aimage != null) { var points = image.findColorJ(aimage,\"金币\"); logd(\"points \"+points); } } main(); image.findColorEx 在当前屏幕中找到颜色和color完全相等的点，并返回该点的左边；如果没有找到，则返回null。 @param color 要寻找的颜色 @param threshold 找色时颜色相似度取值为 0.0 ~ 1.0 @param x 区域的X起始坐标 @param y 区域的Y起始坐标 @param ex 终点X坐标 @param ey 终点Y坐标 @param limit 限制个数 @param orz 方向，分别从1-8 @return 多个Point 坐标点数组或者null function main() { var req = image.requestScreenCapture(10000,0); if (!req) { req = image.requestScreenCapture(10000,0); } if (!req) { toast(\"申请权限失败\"); return; } var points = image.findColorEx(\"0xCDD7E9-0x101010\", 0.9, 0, 0, 0, 0, 10,1); logd(\"points \"+points); } main(); image.findColorExJ 当前屏幕中找到颜色和color完全相等的点，参数从JSON中获取如果没有找到，则返回null。 @param jsonFileName res文件中取色工具生成的JSON文件，只要填写文件名称即可，后缀不用填写 @return 多个Point 坐标点数组或者null function main() { var req = image.requestScreenCapture(10000,0); if (!req) { req = image.requestScreenCapture(10000,0); } if (!req) { toast(\"申请权限失败\"); return; } var points = image.findColorExJ(\"金币\"); logd(\"points \"+points); } main(); image.findMultiColor 多点找色，找到所有符合标准的点，类似于按键精灵的多点找色。 @param image 要找色的图片 @param firstColor 第一个点的颜色 @param threshold 找色时颜色相似度取值为 0.0 ~ 1.0 @param points 字符串类似这样 6|1|0x969696-0x000010,1|12|0x969696,-4|0|0x969696 @param x 区域的X起始坐标 @param y 区域的Y起始坐标 @param ex 终点X坐标 @param ey 终点Y坐标 @param limit 限制个数 @param orz 方向，分别从1-8 @return 多个Point 坐标点数组或者null function main() { var req = image.requestScreenCapture(10000,0); if (!req) { req = image.requestScreenCapture(10000,0); } if (!req) { toast(\"申请权限失败\"); return; } var aimage = image.captureFullScreen(); if (aimage != null) { var points = image.findMultiColor(aimage,\"0xDD7A5F-0x101010\", \"29|25|0xBB454B-0x101010,58|44|0xA6363A-0x101010\", 0.9, 0, 0, 0, 0, 10,1); logd(\"points \"+points); } } main(); image.findMultiColorJ 多点找色，找到所有符合标准的点，参数从JSON文件中读取，类似于按键精灵的多点找色 @param image 要找色的图片 @param jsonFileName res文件中取色工具生成的JSON文件，只要填写文件名称即可，后缀不用填写 @return 多个Point 坐标点数组或者null function main() { var req = image.requestScreenCapture(10000,0); if (!req) { req = image.requestScreenCapture(10000,0); } if (!req) { toast(\"申请权限失败\"); return; } var aimage = image.captureFullScreen(); if (aimage != null) { var points = image.findMultiColorJ(aimage,\"金币\"); logd(\"points \"+points); } } main(); image.findMultiColorEx 多点找色，找到所有符合标准的点，类似于按键精灵的多点找色。 @param firstColor 第一个点的颜色 @param threshold 找色时颜色相似度取值为 0.0 ~ 1.0 @param points 字符串类似这样 6|1|0x969696-0x000010,1|12|0x969696,-4|0|0x969696 @param x 区域的X起始坐标 @param y 区域的Y起始坐标 @param ex 终点X坐标 @param ey 终点Y坐标 @param limit 限制个数 @param orz 方向，分别从1-8 @return 多个Point 坐标点数组或者null function main() { var req = image.requestScreenCapture(10000,0); if (!req) { req = image.requestScreenCapture(10000,0); } if (!req) { toast(\"申请权限失败\"); return; } var points = image.findMultiColorEx(\"0xDD7A5F-0x101010\", \"29|25|0xBB454B-0x101010,58|44|0xA6363A-0x101010\", 0.9, 0, 0, 0, 0, 10,1); logd(\"points \"+points); } main(); image.findMultiColorExJ 多点找色，找到所有符合标准的点，自动抓取当前屏幕的图片,参数从JSON文件中读取，类似于按键精灵的多点找色 @param jsonFileName res文件中取色工具生成的JSON文件，只要填写文件名称即可，后缀不用填写 @return 多个Point 坐标点数组或者null function main() { var req = image.requestScreenCapture(10000,0); if (!req) { req = image.requestScreenCapture(10000,0); } if (!req) { toast(\"申请权限失败\"); return; } var points = image.findMultiColorExJ(\"金币\"); logd(\"points \"+points); } main(); 找图 image.findImage 找图。在大图片image中查找小图片template的位置（模块匹配），找到时返回位置坐标区域(Rect)，找不到时返回null。 @param image 大图片 @param template 小图片（模板） @param x 找图区域 x 起始坐标 @param y 找图区域 y 起始坐标 @param ex 终点X坐标 @param ey 终点Y坐标 @param threshold 图片相似度。取值范围为0~1的浮点数。默认值为0.9。 @param limit 限制结果的数量，如果要找到1个，就填写1，如果是多个请填写多个 @return Rect 区域坐标对象或者null function main() { var request = image.requestScreenCapture(10000,0); if (request){ toast(\"申请成功\"); }else { toast(\"申请失败\"); exit(); } sleep(5000); //从工程目录下res文件夹下读取sms.png文件 var sms=readResAutoImage(\"sms.png\"); //在当前屏幕中查找，并且限制只查找一个 var point = image.findImageEx( sms, 1); logd(\"point \"+point); //抓取屏幕 var aimage = image.captureFullScreen(); logd(\"aimage \"+aimage); if (aimage != null) { //在图片中查找 point = image.findImage(aimage, sms,0,0,0,0,1, 1); logd(\"point \"+point); } } main(); image.findImageEx 找图。在当前屏幕中查找小图片template的位置（模块匹配），找到时返回位置坐标区域(Rect)，找不到时返回null。 @param template 小图片（模板） @param x 找图区域 x 起始坐标 @param y 找图区域 y 起始坐标 @param ex 终点X坐标 @param ey 终点Y坐标 @param threshold 图片相似度。取值范围为0~1的浮点数。默认值为0.9。 @param limit 限制结果的数量，如果要找到1个，就填写1，如果是多个请填写多个 @return Rect 区域坐标对象数组或者null function main() { var request = image.requestScreenCapture(10000,0); if (request){ toast(\"申请成功\"); }else { toast(\"申请失败\"); exit(); } sleep(5000); //从工程目录下res文件夹下读取sms.png文件 var sms=readResAutoImage(\"sms.png\"); //在当前屏幕中查找，并且限制只查找一个 var point = image.findImageEx(sms,0,0,0,0,1, 1); logd(\"point \"+point); } main(); image.matchTemplate 模板匹配 OpenCV模板匹配封装 @param image 大图片 @param template 小图片（模板） @param weakThreshold 图片相似度。取值范围为0~1的浮点数。默认值为0.9。 @param threshold 图片相似度。取值范围为0~1的浮点数。默认值为0.9。 @param rect 找图区域。参见findColor函数关于 rect 的说明。 @param maxLevel 默认为-1，一般而言不必修改此参数。不加此参数时该参数会根据图片大小自动调整。找图算法是采用图像金字塔进行的, level参数表示金字塔的层次, level越大可能带来越高的找图效率，但也可能造成找图失败（图片因过度缩小而无法分辨）或返回错误位置。因此，除非您清楚该参数的意义并需要进行性能调优，否则不需要用到该参数。 @param limit 限制结果的数量，如果要找到1个，就填写1，如果是多个请填写多个 @return Match集合 或者null function main() { var req = image.requestScreenCapture(10000,0); if (!req) { req = image.requestScreenCapture(10000,0); } if (!req) { toast(\"申请权限失败\"); return; } var aimage = image.captureFullScreen(); if (aimage != null) { var temp = readResAutoImage(\"tmp.png\"); var rectp= new Rect(); rectp.left=10; rectp.top=100; rectp.right=100; rectp.bottom=400; var x = image.matchTemplate(aimage, temp,0.9,0.9,rectp,-1,1); logd(x); } } main(); image.matchTemplateEx 模板匹配 OpenCV模板匹配封装，在当前屏幕截图中进行匹配 @param template 小图片（模板） @param weakThreshold 图片相似度。取值范围为0~1的浮点数。默认值为0.9。 @param threshold 图片相似度。取值范围为0~1的浮点数。默认值为0.9。 @param rect 找图区域。参见findColor函数关于 rect 的说明。 @param maxLevel 默认为-1，一般而言不必修改此参数。不加此参数时该参数会根据图片大小自动调整。找图算法是采用图像金字塔进行的, level参数表示金字塔的层次, level越大可能带来越高的找图效率，但也可能造成找图失败（图片因过度缩小而无法分辨）或返回错误位置。因此，除非您清楚该参数的意义并需要进行性能调优，否则不需要用到该参数。 @param limit 限制结果的数量，如果要找到1个，就填写1，如果是多个请填写多个 @return Match集合 或者null function main() { var req = image.requestScreenCapture(10000,0); if (!req) { req = image.requestScreenCapture(10000,0); } if (!req) { toast(\"申请权限失败\"); return; } var aimage = image.captureFullScreen(); if (aimage != null) { var temp = readResAutoImage(\"tmp.png\"); var rectp= new Rect(); rectp.left=10; rectp.top=100; rectp.right=100; rectp.bottom=400; var x = image.matchTemplateEx( temp,0.9,0.9,rectp,-1,1); logd(x); } } main(); 二值化 image.binaryzation 对AutoImage图片进行二值化 @param img AutoImage图片对象 @param type 二值化类型，一般写1即可 0 灰度值大于阈值为最大值，其他值为 1 灰度值大于阈值为0，其他值为最大值 2 灰度值大于阈值的为阈值，其他值不变 3 灰度值大于阈值的不变，其他值为0 4 灰度值大于阈值的为零，其他值不变 7 暂不支持 8 大津法自动寻求全局阈值 16 三角形法自动寻求全局阈值 @param threshold 二值化系数，0 ~ 255 @return AutoImage 对象或者null function main() { var req = image.requestScreenCapture(10000,0); if (!req) { req = image.requestScreenCapture(10000,0); } if (!req) { toast(\"申请权限失败\"); return; } for (var i = 0; i image.binaryzationBitmap 对安卓的 Bitmap 图片进行二值化 @param bitmap Bitmap 图片对象 @param type 二值化类型，一般写1即可 0 灰度值大于阈值为最大值，其他值为 1 灰度值大于阈值为0，其他值为最大值 2 灰度值大于阈值的为阈值，其他值不变 3 灰度值大于阈值的不变，其他值为0 4 灰度值大于阈值的为零，其他值不变 7 暂不支持 8 大津法自动寻求全局阈值 16 三角形法自动寻求全局阈值 @param threshold 二值化系数，0 ~ 255 @return Bitmap 对象或者null function main() { var req = image.requestScreenCapture(10000,0); if (!req) { req = image.requestScreenCapture(10000,0); } if (!req) { toast(\"申请权限失败\"); return; } for (var i = 0; i 其他 image.readImage 读取在路径path的图片文件并返回一个{@link AutoImage}对象。如果文件不存在或者文件无法解码则返回null。 @param path 图片路径 @return AutoImage 对象或者null function main() { var autoimg = image.readImage(\"/sdcard/a.png\"); } main(); image.readBitmap 读取在路径path的图片文件并返回一个{@link AutoImage}对象。如果文件不存在或者文件无法解码则返回null。 @param path 图片路径 @return android的bitmap对象或者null function main() { var autoimg = image.readBitmap(\"/sdcard/a.png\"); } main(); image.pixelInImage 返回图片image在点(x, y)处的像素的ARGB值。 该值的格式为0xAARRGGBB，是一个\"32位整数\" 坐标系以图片左上角为原点。以图片左侧边为y轴，上侧边为x轴。 @param image 图片 @param x 要获取的像素的横坐标。 @param y 要获取的像素的纵坐标。 @return 整型 function main() { var imageX = image.captureFullScreen(); var color = image.pixelInImage(imageX,100,100); } main(); image.getPixelBitmap 取得Bitmap图片的某个点的颜色值 @param bitmap 图片对象 @param x x坐标点 @param y y坐标点 @return int 颜色值 function main() { var bitmap = image.captureScreenBitmap(\"jpg\",800,800,100,100,100); var color = image.getPixelBitmap(bitmap,100,100); } main(); image.getPixelsBitmap 取得Bitmap图片的某个区域点的颜色值，等同于 Bitmap.getPixels @param bitmap 图片对象 @param arraySize 要返回的区域数组的大小 @param offset 写入到pixels[]中的第一个像素索引值 @param stride pixels[]中的行间距个数值(必须大于等于位图宽度)。可以为负数 @param x 　从位图中读取的第一个像素的x坐标值。 @param y 从位图中读取的第一个像素的y坐标值 @param width 　　从每一行中读取的像素宽度 @param height 　　　读取的行数 @return int 颜色值数组 function main() { var bitmap = image.captureScreenBitmap(\"jpg\",800,800,100,100,100); var w = bitmap.getWidth(); var h =bitmap.getHeight(); var mPixels = image.getPixelsBitmap(bitmap,w*h, 0, w, 0, 0,w, h); } main(); 图片转换 image.saveTo 保存到文件中 @param img 图片对象 @param path 路径 @return bool true代表成功，false 代表失败 function main() { var imageX = image.captureFullScreen(); var r = image.saveTo(imageX,\"/sdard/a.png\"); toast(\"result \"+r); } main(); image.toBase64Format 转成base64的字符串, jpg格式较小，可以减少内存 @param img 图片对象 @param format 格式 jpg或者 png @param q 质量 1-100，质量越大 越清晰 @return 字符串 function main() { var imageX = image.captureFullScreen(); var r = image.toBase64Format(imageX,\"jpg\",50); toast(\"result \"+r); } main(); image.clip 剪切图片 @param img 图片对象 @param x x起始坐标 @param y y起始坐标 @param ex 终点X坐标 @param ey 终点Y坐标 @return AutoImage 对象或者null function main() { var imageX = image.captureFullScreen(); var r = image.clip(imageX,100,100,300,400); toast(\"result \"+r); } main(); image.pixel 取得图片的某个点的颜色值 @param img 图片对象 @param x x坐标点 @param y y坐标点 @return int 颜色值 function main() { var imageX = image.captureFullScreen(); var r = image.pixel(imageX,100,100); toast(\"result \"+r); } main(); image.isRecycled 是否被回收了 @param img 图片对象 @return bool true代表已经被回收了 function main() { var imageX = image.captureFullScreen(); var r = image.isRecycled(imageX); toast(\"result \"+r); } main(); image.recycle 回收图片 @param img 图片对象 function main() { var imageX = image.captureFullScreen(); image.recycle(imageX); } main(); image.clipBitmap (剪裁bitmap) 剪裁图片，请自行判断参数，正确性 @param bitmap 图片 @param x 开始X坐标 @param y 开始Y坐标 @param w 剪裁宽度 @param h 剪裁高度 @return {Bitmap} 安卓的Bitmap对象 function main() { var request = image.requestScreenCapture(10000,0); if (!request) { request = image.requestScreenCapture(10000,0); } logd(\"申请截图结果... \"+request) for (var i = 0; i image.base64Bitmap (base64转bitmap) base64字符串转为Bitmap图片 @param data base64 数据 @param flag base64格式的标示，一般为0， 可选参数为 ：0 默认， 1 无填充模式，2 无换行模式，4 换行模式 @return {Bitmap} 安卓的Bitmap对象 function main() { var request = image.requestScreenCapture(10000,0); if (!request) { request = image.requestScreenCapture(10000,0); } logd(\"申请截图结果... \"+request) for (var i = 0; i image.bitmapBase64 (bitmap转base64) bitmap转为base64 @param bitmap 图片 @param format 格式，jpg或者png @param q 质量 1 - 100 @return {string} base64字符串 function main() { var request = image.requestScreenCapture(10000,0); if (!request) { request = image.requestScreenCapture(10000,0); } logd(\"申请截图结果... \"+request) for (var i = 0; i "},"zh-cn/funcs/device-api.html":{"url":"zh-cn/funcs/device-api.html","title":"设备函数","keywords":"","body":"说明 设备模块函数主要是跟设备信息相关联 设备模块的对象前缀是device，例如 device.getIMEI()这样调用 函数 device.getIMEI() 获取手机的IMEI @return 字符串 function main(){ var imei = device.getIMEI(); toast(imei); } main(); device.getScreenWidth() 取得屏幕宽度 @return 整型 function main(){ var width = device.getScreenWidth(); toast(width); } main(); device.getScreenHeight() 取得屏幕高度 @return 整型 function main(){ var height = device.getScreenHeight(); toast(height); } main(); device.getAndroidId() 取得Android ID @return 字符串 function main(){ var androidId = device.getAndroidId(); toast(androidId); } main(); device.getBrand() 取得手机品牌 @return 字符串 function main(){ var brand = device.getBrand(); toast(brand); } main(); device.getModel() 取得手机机型 @return 字符串 function main(){ var model = device.getModel(); toast(model); } main(); device.getImsi() 取得手机卡号 @return 字符串 function main(){ var imsi = device.getImsi(); toast(imsi); } main(); device.getSerial() 取得手机串号 @return 字符串 function main(){ var serial = device.getSerial(); toast(serial); } main(); device.getSdkInt() 取得手机SDK 版本号，例如 23 @return 字符串 function main(){ var sdkInt = device.getSdkInt(); toast(sdkInt); } main(); device.getOSVersion() 取得手机版本号,例如 6.0等字符串 @return 字符串 function main(){ var osVersion = device.getOSVersion(); toast(osVersion); } main(); device.getMacAddress() 获取mac地址 @return 字符串 function main(){ var res = device.getMacAddress(); toast(res); } main(); device.getBattery() 取得电量 @return int型 function main(){ var res = device.getBattery(); toast(res); } main(); device.getTotalMem() 取得总内存 @return long型 function main(){ var res = device.getTotalMem(); toast(res); } main(); device.getAvailMem() 取得可用内存 @return long型 function main(){ var res = device.getAvailMem(); toast(res); } main(); device.isCharging() 是否正在充电 @return 布尔型 function main(){ var res = device.isCharging(); toast(res); } main(); device.vibrate() 发出震动 单位是毫秒 function main(){ device.vibrate(1*1000); } main(); device.cancelVibration() 取消震动 function main(){ device.cancelVibration(); } main(); "},"zh-cn/funcs/file-api.html":{"url":"zh-cn/funcs/file-api.html","title":"文件函数","keywords":"","body":"说明 文件模块函数主要是跟文件信息相关联 文件模块的对象前缀是file，例如 file.readFile()这样调用 函数 file.readFile 将文件读取为字符串 @param path 文件路径 @return 字符串 function main(){ var data = file.readFile(\"/sdcard/test.txt\"); toast(data); } main(); file.listDir 列出文件下的所有文件 @param path 路径 @return 路径字符串数组 function main(){ var data = file.listDir(\"/sdcard/\"); for(var i = 0; i file.writeFile 将字符串存储到文件中 @param data 字符串 数据 @param path 文件路径 function main(){ var data=\"Test\"; file.writeFile(data,\"/sdcard/test.txt\"); } main(); file.create 创建一个文件或者文件夹 @param path 文件或者文件夹路径 @return 布尔型 true 代表创建成功 function main(){ var create=file.create(\"/sdcard/test.txt\"); toast(create); } main(); file.readAssets 从APK的assets文件夹中读取数据为字符串 @param path assets文件夹中的文件路径，例如 data/a.txt @return 字符串 function main(){ var data=file.readAssets(\"data/test.txt\"); toast(data); } main(); file.deleteAllFile 删除所有文件或者文件夹 @param path 文件或者文件路径 function main(){ file.deleteAllFile(\"data/test.txt\"); } main(); file.appendLine 写入一行到文件中,追加模式 @param data 行数据 @param path 文件或者文件路径 @return 布尔型 true代表成功 false代表失败 function main(){ var data=\"sss\"; var t=file.appendLine(data,\"/sdcard/test.txt\"); toast(t); } main(); file.readLine 读取一行数据，如果行号不对，返回的是空 @param path 路径 @param lineNo 行号 @return 字符串 返回一行字符串 function main(){ var t=file.readLine(\"/sdcard/test.txt\",1); toast(t); } main(); file.readAllLines 读取所有数据 @param path 路径 @return 字符串 function main(){ var t=file.readAllLines(\"/sdcard/test.txt\"); toast(t); } main(); file.mkdirs 创建文件夹 @param path 路径 @return 布尔型 true 代表成功，false代表失败 function main(){ var t=file.mkdirs(\"/sdcard/testdir/\"); toast(t); } main(); file.exists 文件或者文件夹是否存在 @param path 路径 @return 布尔型 true 代表成功，false代表失败 function main(){ var t=file.exists(\"/sdcard/testdir/\"); toast(t); } main(); "},"zh-cn/funcs/http-api.html":{"url":"zh-cn/funcs/http-api.html","title":"网络函数","keywords":"","body":"说明 网络模块函数主要是跟网络请求信息相关联 网络模块的对象前缀是http，例如 http.downloadFile()这样调用 函数 http.request 万能请求函数 HTTP万能请求 @param param map参数，包含的参数有 url:字符串 请求的地址 timeout:整型毫秒，超时时间 method: POST ,GET,PUT 字符串，代表请求的方法 proxy: 代理地址，map参数 包含主机和端口 例如 {\"host\":\"11\",\"port\":111} followRedirects:是否自动跳转 true 或者 false requestBody: 请求的body体，如果是JSON，就是JSON字符串 userAgent:字符串 HTTP 的UA ignoreContentType:是否忽略内容类型 true 或者 false ignoreHttpErrors:是否忽略错误 true 或者 false maxBodySize : 整型，HTTP BODY最大值 referrer:字符串，请求来源 header: HTTP 请求头，map参数,例如 {\"UA\":\"test\"} cookie: HTTP 请求Cookie，map参数, 例如 {\"a\":1} data:HTTP POST的数据，map参数, 例如 {\"a\":1} file:要上传的文件，集合参数，例如 [{\"key\":\"a1\",\"fileName\":\"a.txt\",\"filePath\":\"/sdcard/\"},{\"key\":\"a1\",\"fileName\":\"a.jpg\",\"filePath\":\"/sdcard/\",\"contentType\":\"image/jpg\"}] 其中contentType可有可无 responseCharset: 字符串，强制设置响应内容的编码集 @return Response 对象或者null function main(){ http_request(); } function http_request() { //url:string //timeout:int ms //method: post ,get //proxy: {\"host\":\"11\",\"port\":111} //followRedirects:true false //requestBody: string //userAgent:string //ignoreContentType:true false //ignoreHttpErrors:true false //maxBodySize : int //referrer:string //header:{\"UA\":\"test\"} //cookie:{\"a\":1} //data:{\"a\":1} //file:[{}] //responseCharset: string var md = utils.dataMd5(\"12345\"); var md2 = utils.fileMd5(\"/sdcard/sb.png\"); var url = \"http://192.168.0.5:8081/api/request\"; var proxy = {\"host\": \"192.168.0.5\", \"port\": \"100\"}; var userAgent = \"xxx\"; var followRedirects = false; var requestBody = JSON.stringify({\"A\": 111}); var ignoreContentType = true; var ignoreHttpErrors = true; var referrer = \"xxx\"; var header = { \"Content-Type\": \" application/json; charset=UTF-8\", \"User-Agent\": \"from test\", \"ddd\": md, \"dd2\": md2, \"imei\": device.getIMEI() }; var cookie = { \"cookie1\": \"tst1\", \"cookie2\": \"tst2\" }; var data = { \"a1\": \"aaa\", \"pwd2\": md, \"md2\": md2 }; var file = [ { \"key\": \"file\", \"fileName\": \"f.png\", \"filePath\": \"/sdcard/sb.png\" }, { \"key\": \"file\", \"fileName\": \"f2.png\", \"filePath\": \"/sdcard/sde.png\", \"contentType\": \"image/png\" } ]; var params = { \"url\": url, \"method\": \"POST\", \"userAgent\": userAgent, \"referrer\": \"baidu.com\", \"cookie\": cookie, \"data\": data, \"file\": file }; var x = http.request(params); if (x) { logd(\"header=> \" + x.header); logd(\"cookie=> \" + x.cookie); logd(\"statusCode=> \" + x.statusCode); logd(\"statusMessage=> \" + x.statusMessage); logd(\"charset=> \" + x.charset); logd(\"contentType=> \" + x.contentType); logd(\"body=> \" + x.body); } else { loge(\"无结果\"); } } main(); http.requestEx 万能请求函数(扩展) HTTP万能请求 @param param map参数，包含的参数有 url:字符串 请求的地址 timeout:整型毫秒，超时时间 method: POST ,GET,PUT 字符串，代表请求的方法 proxy: 代理地址，map参数 包含主机和端口 例如 {\"host\":\"11\",\"port\":111} followRedirects:是否自动跳转 true 或者 false requestBody: 请求的body体，如果是JSON，就是JSON字符串 userAgent:字符串 HTTP 的UA ignoreContentType:是否忽略内容类型 true 或者 false ignoreHttpErrors:是否忽略错误 true 或者 false maxBodySize : 整型，HTTP BODY最大值 referrer:字符串，请求来源 header: HTTP 请求头，map参数,例如 {\"UA\":\"test\"} cookie: HTTP 请求Cookie，map参数, 例如 {\"a\":1} data:HTTP POST的数据，map参数, 例如 {\"a\":1} file:要上传的文件，集合参数，例如 [{\"key\":\"a1\",\"fileName\":\"a.txt\",\"filePath\":\"/sdcard/\"},{\"key\":\"a1\",\"fileName\":\"a.jpg\",\"filePath\":\"/sdcard/\",\"contentType\":\"image/jpg\"}] 其中contentType可有可无 responseCharset: 字符串，强制设置响应内容的编码集 @return Response 对象或者null function main(){ http_request(); } function http_request() { //url:string //timeout:int ms //method: post ,get //proxy: {\"host\":\"11\",\"port\":111} //followRedirects:true false //requestBody: string //userAgent:string //ignoreContentType:true false //ignoreHttpErrors:true false //maxBodySize : int //referrer:string //header:{\"UA\":\"test\"} //cookie:{\"a\":1} //data:{\"a\":1} //file:[{}] //responseCharset: string var md = utils.dataMd5(\"12345\"); var md2 = utils.fileMd5(\"/sdcard/sb.png\"); var url = \"http://192.168.0.5:8081/api/request\"; var proxy = {\"host\": \"192.168.0.5\", \"port\": \"100\"}; var userAgent = \"xxx\"; var followRedirects = false; var requestBody = JSON.stringify({\"A\": 111}); var ignoreContentType = true; var ignoreHttpErrors = true; var referrer = \"xxx\"; var header = { \"Content-Type\": \" application/json; charset=UTF-8\", \"User-Agent\": \"from test\", \"ddd\": md, \"dd2\": md2, \"imei\": device.getIMEI() }; var cookie = { \"cookie1\": \"tst1\", \"cookie2\": \"tst2\" }; var data = { \"a1\": \"aaa\", \"pwd2\": md, \"md2\": md2 }; var file = [ { \"key\": \"file\", \"fileName\": \"f.png\", \"filePath\": \"/sdcard/sb.png\" }, { \"key\": \"file\", \"fileName\": \"f2.png\", \"filePath\": \"/sdcard/sde.png\", \"contentType\": \"image/png\" } ]; var params = { \"url\": url, \"method\": \"POST\", \"userAgent\": userAgent, \"referrer\": \"baidu.com\", \"cookie\": cookie, \"data\": data, \"file\": file }; var x = http.requestEx(params); if (x) { logd(\"header=> \" + x.header); //直接取值 logd(\"header=> \" + x.header[\"Location\"]); for (var d in x.header){ logd(\"header key \"+d +\" \"+x.header[d]); } logd(\"cookie=> \" + x.cookie); for (var d in x.cookie){ logd(\"cookie key \"+d +\" \"+x.cookie[d]); } logd(\"cookie=> \" + x.cookie[\"aa\"]); logd(\"statusCode=> \" + x.statusCode); logd(\"statusMessage=> \" + x.statusMessage); logd(\"charset=> \" + x.charset); logd(\"contentType=> \" + x.contentType); logd(\"body=> \" + x.body); } else { loge(\"无结果\"); } } main(); http.downloadFile 下载远程文件到本地,支持断点续传 @param remoteUrl 远程文件URL @param file 要保存到本地的文件对象 @param timeout 下载超时，单位是毫秒 @param headers – 头标志例如{“a”:“11”} @return true 代表成功 false代表失败 function main(){ var url = \"https://imtt.dd.qq.com/16891/apk/DF4FD15AF9A9B51BA74D2710CF738EEF.apk?fsname=com.ishugui_3.9.2.3068_3923068.apk&csr=1bbd\"; var x = http.downloadFile(url, \"/sdcard/ss.apk\", 10 * 1000, {\"User-Agent\": \"test\"}); toast(\"download result-> \" + x); } main(); http.downloadFileDefault 下载远程文件到本地,支持断点续传，默认超时时间为30秒 @param remoteUrl 远程文件URL @param file 要保存到本地的文件对象 @param headers – 头标志例如{“a”:“11”} @return true 代表成功 false代表失败 function main(){ var url = \"https://imtt.dd.qq.com/16891/apk/DF4FD15AF9A9B51BA74D2710CF738EEF.apk?fsname=com.ishugui_3.9.2.3068_3923068.apk&csr=1bbd\"; var x = http.downloadFileDefault(url, \"/sdcard/ss.apk\", {\"User-Agent\": \"test\"}); toast(\"download result-> \" + x); } main(); http.httpGetDefault Http GET 请求 @param url 请求的URL @param timeout 超时时间 单位毫秒 @param headers – 头标志例如{“a”:“11”} @return 字符串 请求后返回的字符串 function main(){ var url = \"http://192.168.0.5:8081/api/httpGet?a=1\"; var x = http.httpGetDefault(url, 10 * 1000, {\"User-Agent\": \"test\"}); toast(\" result-> \" + x); loge(\"result -> \" + x); } main(); http.httpGet Http GET 请求 @param url 请求的URL @param params 参数Map表 例如 {\"a\":\"1\"} 这样的参数或者字符串 @param timeout 超时时间 单位毫秒 @param headers – 头标志例如{“a”:“11”} @return 字符串 请求后返回的字符串 function main(){ var url = \"http://192.168.0.5:8081/api/httpGet?a=1\"; var pa = {\"b\": \"22\"}; var x = http.httpGet(url, pa, 10 * 1000, {\"User-Agent\": \"test\"}); toast(\" result-> \" + x); loge(\"result -> \" + x); } main(); http.httpPost Http Post 请求 @param url 请求的URL @param params 参数，例如 {\"a\":\"1\"} 这样的参数或者字符串 @param files 要上传的文件，例如 {\"file1\":\"/sdcard/1.png\"}这样的文件参数 @param timeout 超时时间 单位毫秒 @param headers – 头标志例如{“a”:“11”} @return 字符串 请求后返回的字符串 function main(){ //不带文件的请求 var url = \"http://192.168.0.5:8081/api/httpPost\"; var pa = {\"b\": \"我是b的值\"}; var x = http.httpPost(url, pa, null, 10 * 1000, {\"User-Agent\": \"test\"}); toast(\" result-> \" + x); loge(\"result -> \" + x); } main(); function main(){ //带上传文件的请求 var url = \"http://192.168.0.5:8081/api/httpPost\"; var pa = {\"b\": \"我是b的值\"}; var files = {\"file1\": \"/sdcard/p.json\", \"file2\": \"/sdcard/z.xml\"}; var x = http.httpPost(url, pa, files, 10 * 1000, {\"User-Agent\": \"test\"}); toast(\" result-> \" + x); loge(\"result -> \" + x); } main(); http.postJSON HTTP POST JSON数据 @param url 请求的URL @param json json数据 @param timeout – 超时时间 单位毫秒 @param headers – 头标志例如{“a”:“11”} @return 字符串 请求后返回的字符串 function main(){ var url = \"http://192.168.0.5:8081/api/postJSON\"; var pa = {\"b\": \"我是b的值\"}; var x = http.postJSON(url, pa, 10 * 1000, {\"User-Agent\": \"test\"}); toast(\" result-> \" + x); loge(\"result -> \" + x); } main(); http.newWebsocket websocket通信 创建一个websocket @param url 要连接的地址 @param header 参数头 @return {@link WebSocket } WebSocket对象 function main(){ //新建一个ws连接 var ws =http.newWebsocket(\"http://192.168.1.180:9909/ws\",null); //设置连接打开的时候监听器 ws.onOpen(function (ws,code,msg){ logi(\"onOpen code \"+code +\" msg:\"+msg); }) //设置有文本信息监听器 ws.onText(function (ws,text){ logi(\" onText \"+text); }) //设置关闭时候的监听器 ws.onClose(function (ws,code,reason){ logi(\" onClose \"+code +\" reason : \"+reason+\" remote:\"); }) ws.onError(function (ws,msg){ logi(\" onError \"+msg ); }) // bytes 是 java的okio.ByteString 对象 ws.onBinary(function (ws,bytes){ logi(\" onBinary \"+bytes.hex() ); logi(\" onBinary \"+bytes.utf8() ); logi(\" onBinary \"+bytes.md5() ); }) //开始连接 ws.connect(); sleep(1000) if (ws.isConnected()) { //发送文本 ws.sendText(\"ping\"); } logd(\"isClosed \"+ws.isClosed()) sleep(1000) //关闭连接 ws.close(); } main(); WebSocket 对象函数 connect 开始异步连接 详细代码看例子 isClosed 是否已经关闭 @return true 代表已经关闭，false 未关闭 详细代码看例子 isConnected 是否已经连接了 @return true 代表已经连接，false 未关闭 详细代码看例子 close 关闭链接 详细代码看例子 sendText 发送文本消息 @param text 文本信息 详细代码看例子 sendBinary 发送字节信息 @param bin okio.ByteString 对象 详细代码看例子 onOpen 当连接打开的时候事件回调 @param callback 回调函数 详细代码看例子 onText 当有文本信息发送过来的时候回调 @param callback 回调函数 详细代码看例子 onClose 当关闭的时候回调 @param callback 回调函数 详细代码看例子 onError 当发生错误的时候回调 @param callback 回调函数 详细代码看例子 onBinary 当有二进制数据过来的时候回调 @param callback 回调函数 详细代码看例子 "},"zh-cn/funcs/thread-api.html":{"url":"zh-cn/funcs/thread-api.html","title":"线程函数","keywords":"","body":"说明 线程模块函数主要是跟线程信息相关联 线程模块的对象前缀是thread，例如 thread.execFuncSync()这样调用 函数 setTimeout 设定延迟多少毫秒后执行函数，在子线程中执行 @param func 要执行的函数 @param timeout 延迟时间，单位是毫秒 线程对象 该对象可以进行取消 function main(){ var t=setTimeout(function() { toast(\"我是一秒后执行的代码\"); },1000); } main(); cancelTimeout 取消延迟执行 @param t 要取消的函数 function main(){ var t=setTimeout(function() { toast(\"我是一秒后执行的代码\"); },1000); //取消就不会执行了 cancelTimeout(t); } main(); setInterval 设置多少周期进行执行一次，在子线程中执行 @param func 函数 @param interval 周期时间，单位是毫秒 @return 线程对象 该对象可以进行取消 function main(){ var t=setInterval(function() { toast(\"我是每隔一秒执行的代码\"); },1000); } main(); cancelInterval 取消周期执行的函数 @param t 要取消的函数 function main(){ var t=setInterval(function() { toast(\"我是每隔一秒执行的代码\"); },1000); cancelInterval(t); } main(); execSync 执行某个函数并且等待true返回，如果函数中返回的是true，该方法将立刻执行完毕 @param condition 条件函数 @param timeout 超时时间，单位是毫秒 @return 布尔型 返回一个布尔型值 function main(){ execSync(function() { logd(\"我是同步执行的代码\"); },1000); } main(); thread.stopAll 取消所有正在运行的线程 function main(){ execSync(function() { logd(\"我是同步执行的代码\"); },1000); thread.stopAll(); } main(); thread.execAsync 异步执行线程，这里会将Runnable放到线程池中进行管理 @param runnable Runnable对象 function main(){ var tid =thread.execAsync(function() { while (true){ logd(\"我是异步执行的代码\"); sleep(1000); if(thread.isCancelled(tid)){ break; } } }); logd(\"tid \"+tid); //5s后取消线程 sleep(5000); logd(\"取消线程 \"+tid); thread.cancelThread(tid); sleep(5000); logd(\"结束 \"); } main(); thread.execSync 执行某个函数并且等待true返回，如果函数中返回的是true，该方法将立刻执行完毕 @param condition 条件函数 @param timeout 超时时间，单位是毫秒 @return 布尔型 返回一个布尔型值 function main(){ thread.execSync(function() { logd(\"我是同步执行的代码\"); },1000); } main(); thread.cancelThread 取消线程的执行 @param t 线程对象ID @return boolean function main(){ var tid =thread.execAsync(function() { while (true){ logd(\"我是异步执行的代码\"); sleep(1000); if(thread.isCancelled(tid)){ break; } } }); logd(\"tid \"+tid); //5s后取消线程 sleep(5000); logd(\"取消线程 \"+tid); thread.cancelThread(tid); sleep(5000); logd(\"结束 \"); } main(); thread.isCancelled 取消线程的执行 @param t 线程对象ID @return boolean true代表已经取消了，false表示未取消 function main(){ var tid =thread.execAsync(function() { while (true){ logd(\"我是异步执行的代码\"); sleep(1000); if(thread.isCancelled(tid)){ break; } } }); logd(\"tid \"+tid); //5s后取消线程 sleep(5000); logd(\"取消线程 \"+tid); thread.cancelThread(tid); sleep(5000); logd(\"结束 \"); } main(); "},"zh-cn/funcs/utils-api.html":{"url":"zh-cn/funcs/utils-api.html","title":"常用工具函数","keywords":"","body":"说明 工具类模块函数主要是跟Android常用的信息相关联 工具类模块的对象前缀是utils，例如 utils.requestShowLogPermission()这样调用 函数 打开App相关 utils.openApp 打开APP @param packageName 程序的包名 @return 布尔型 true 代表成功，false 代表失败 function main(){ utils.openApp(\"com.xx\"); } main(); utils.openAppByName 打开APP，通过应用名称 @param appName 程序名称，比如今日头条 @return 布尔型 true 代表成功，false 代表失败 function main(){ utils.openAppByName(\"xx\"); } main(); utils.openActivity 打开一个activity，通过map参数 @param map 例如{\"action\":\"\"},key的固定只有 action: 标准的android action字符串 uri: uri可以是http网址，也可以是文件file:///地址，也可以是 URLSchema语法 type: uri对应的type，等同于MIME类型，例如安装apk包的type是 application/vnd.android.package-archive pkg: 要打开的activity对应的包名 className: 要打开的 className 对应的类名 flag: androi打开activity 标准的flag标志位，特殊情况下可以填写 其他的都是属于intent参数了 @return 布尔型 true 代表成功，false 代表失败 function main(){ //打开安装包界面 var m ={ \"action\":\"android.intent.action.VIEW\", \"uri\":\"file:///sdcard/a.apk\", \"type\":\"application/vnd.android.package-archive\" }; var x = utils.openActivity(m); logd(\"x \"+x); var map={ \"uri\":\"xx://xx/live/6701887916223941379\", }; utils.openActivity(map); } main(); 图库相关 utils.insertImageToAlbum 将图片插入到相册中，此方法会立刻更新相册数据 @param path 图片路径 function main(){ utils.insertImageToAlbum(\"/sdcard/a.png\"); } main(); utils.insertVideoToAlbum 将视频插入到相册中，此方法会立刻更新相册数据 @param path 视频路径 function main(){ utils.insertVideoToAlbum(\"/sdcard/a.mp4\"); } main(); 其他 utils.readConfigInt 读取JSON中的整型数据 @param jsonObject JSON对象 @param key 配置项目 @return 整型，找不到就返回0 function main(){ var testData = utils.readConfigInt(jsonObject,\"test_key\"); } main(); utils.readJSONString 读取JSON中的字符串数据 @param jsonObject JSON对象 @param key 配置项目 @return 字符串 找不到就返回空字符串 function main(){ var testData = utils.readConfigString(jsonObject,\"test_key\"); } main(); utils.isObjectNull 判断一个对象为空 @param o 对象 @return true或者false function main(){ var isNull = utils.isObjectNull(\"test_key\"); } main(); utils.isObjectNotNull 判断一个对象不为空 @param o 对象 @return true或者false function main(){ var isNull = utils.isObjectNotNull(\"test_key\"); } main(); utils.getRatio 取得比例，例如10参数，就是返回10%的比例，如果是true，说明随机比例正确，否则不正确 @param ratio 浮点型 1-100 @return true或者false function main(){ var ratio = utils.getRatio(20f); toast(ratio); } main(); utils.getRangeInt 取得某个范围的随机值 @param min 最小值 @param max 最大值 @return 在min和max中间的值,包含最大和最小值 function main(){ var value = utils.getRangeInt(1,100); toast(value); } main(); utils.isTrue 判断布尔型对象是否为真 @param r 布尔型对象 @return true 或者 false function main(){ var value = utils.isTrue(true); } main(); utils.fileMd5 文件的MD5 @param file 文件路径 @return 文件MD5字符串或者null function main(){ var md5 = utils.fileMd5(\"/sdcard/a.txt\"); } main(); utils.dataMd5 数据计算出来的MD5 @param data 数据 @return 数据MD5字符串或者null function main(){ var md5 = utils.dataMd5(\"data\"); } main(); utils.randomInt 随机整型数据 @param length 位数，要随机产生多少位的整型数据 @return 整型 function main(){ var r = utils.randomInt(2); } main(); utils.randomCharNumber 取得随机的数字和字母 @param length 长度 @return 字符串数字混合 function main(){ var r = utils.randomCharNumber(2); } main(); utils.getApkPkgName 取得App文件的包名 @param filePath 文件路径 @return 字符串 function main(){ var pkgName = utils.getApkPkgName(\"/sdcard/app.apk\"); } main(); utils.isAppExist App是否已经安装 @param packageName 应用程序的包名 @return true 代表已经安装，false代表未安装 function main(){ var result = utils.isAppExist(\"com.xx\"); } main(); utils.getAppVersionCode 取得已安装的程序的版本整型标示 @param packageName 应用程序的包名 @return 整型 function main(){ var versionCode = utils.getAppVersionCode(\"com.xx\"); } main(); utils.getAppVersionName 取得已安装的程序的版本字符串标示 @param packageName 应用程序的包名 @return 字符串 例如 1.0.0 function main(){ var r = utils.getAppVersionName(\"com.xx\"); } main(); utils.setClipboardText 设置剪贴板文本 @param text 文本 @return boolean function main(){ var r = utils.setClipboardText(\"com.xx\"); toast(\"设置结果:\"+r); } main(); utils.getClipboardText 读取剪贴板文本 @return string function main(){ var r = utils.getClipboardText(); toast(\"读取结果:\"+r); } main(); "},"zh-cn/funcs/shell-api.html":{"url":"zh-cn/funcs/shell-api.html","title":"Shell命令函数","keywords":"","body":"说明 代理模式下才能使用该函数，用户执行shell命令 shell模块的对象前缀是shell，例如 shell.installApp()这样调用 shell.installApp 安装 apk @param path 文件路径 @return true 代表安装成功，false 代表安装失败 function main(){ var result = shell.installApp(\"/sdcard/app.apk\"); } main(); shell.uninstallApp 卸载应用程序 @param packageName 应用程序的包名 @return true 代表卸载成功，false 代表卸载失败 function main(){ var result = shell.uninstallApp(\"com.xx\"); } main(); shell.stopApp 停止正在执行的应用 @param packageName 应用程序的包名 @return true 代表成功，false 代表失败 function main(){ var result = shell.stopApp(\"com.xx\"); } main(); shell.execCommand 执行Shell命令 @param command 命令，例如安装App ： pm install /sdcard/app.apk @return 命令执行后返回的字符串结果 function main(){ var result = shell.execCommand(\"pm install /sdcard/app.apk\"); } main(); shell.sudo 执行root模式下，相关的命令，需要有root权限 @param command 命令，例如安装App ： pm install /sdcard/app.apk @return 命令执行后返回的字符串结果 function main(){ var result = shell.sudo(\"pm install /sdcard/app.apk\"); } main(); shell.execAgentCommand 执行shell命令。需要启动代理服务 @param command 命令，例如安装App ： pm install /sdcard/app.apk @return 命令执行后返回的字符串结果 function main(){ var result = shell.execAgentCommand(\"pm install /sdcard/app.apk\"); } main(); "},"zh-cn/funcs/sqlite-api.html":{"url":"zh-cn/funcs/sqlite-api.html","title":"Sqlite命令函数","keywords":"","body":"说明 sqlite模块函数主要是用于操作sqlite数据库 sqlite模块的对象前缀是sqlite，例如 sqlite.close()这样调用 sqlite 教程：https://www.runoob.com/sqlite/sqlite-tutorial.html 函数 sqlite.connectOrCreateDb 连接数据库 创建或者链接一个数据库 @param dbName 数据库名称 @return boolean true 代表请求权限成功，false代表失败 function main(){ var create = sqlite.connectOrCreateDb(\"test.db\"); logd(\"create db result：\"+create); } main(); sqlite.createTable 创建表 创建数据表 @param tableName 表名称 @param columns 列名称，例如 [\"name\",\"pwd\"] @return boolean true 代表请求权限成功，false代表失败 function main(){ var tableName=\"tbl_user\"; var columns=[\"name\",\"pwd\"]; var createTable = sqlite.createTable(tableName,columns); logd(\"createTable result：\"+createTable); } main(); sqlite.insert 插入数据 插入数据 @param tableName 表名 @param map 数据的map表 @return boolean true 代表请求权限成功，false代表失败 function main(){ var tableName=\"tbl_user\"; var map={ \"name\":\"我是名称\", \"pwd\":\"我是密码\" }; var insert = sqlite.insert(tableName,map); logd(\"insert result：\"+insert); } main(); sqlite.update 更新数据 更新数据 @param tablename 表名称 @param map 数据的map表 @param where 条件语句 @return boolean true 代表请求权限成功，false代表失败 function main(){ var tableName=\"tbl_user\"; var map={ \"name\":\"我是名称22\" }; var where=\"id>3\"; var update = sqlite.update(tableName,map,where); logd(\"update result：\"+update); } main(); sqlite.query 查询数据 查询数据 @param sql sql语句 @return JSON | 数据集合对象 function main(){ var tableName=\"tbl_user\"; var sql=\"select * from \"+tableName; var data = sqlite.query(sql); logd(\"data result：\"+JSON.stringify(data)); } main(); sqlite.delete 删除数据 删除数据 @param sql sql语句 @return boolean true 代表请求权限成功，false代表失败 function main(){ var tableName=\"tbl_user\"; var sql=\"delete from \"+tableName+\" where id>3;\"; var result = sqlite.delete(sql); logd(\"delete result：\"+ result); } main(); sqlite.execSql 执行sql 查询数据 @param sql sql语句 @return boolean true 代表请求权限成功，false代表失败 function main(){ var tableName=\"tbl_user\"; var sql=\"delete from \"+tableName+\" where id>3;\"; var result = sqlite.execSql(sql); logd(\"execSql result：\"+ result); } main(); sqlite.dropDatabase 删除数据库 删除数据库 @return boolean true 代表请求权限成功，false代表失败 function main(){ var result = sqlite.dropDatabase(); logd(\"dropDatabase result：\"+ result); } main(); sqlite.dropTable 删除表 删除表 @param table 表名 @return boolean true 代表请求权限成功，false代表失败 function main(){ var tableName=\"tbl_user\"; var result = sqlite.dropTable(tableName); logd(\"dropTable result：\"+ result); } main(); sqlite.close 关闭数据库链接，释放资源 关闭数据库链接，释放资源 @return boolean true 代表请求权限成功，false代表失败 function main(){ var result = sqlite.close(); logd(\"close result：\"+ result); } main(); "},"zh-cn/funcs/ui-custom.html":{"url":"zh-cn/funcs/ui-custom.html","title":"原生UI定制","keywords":"","body":"说明 EasyClick 遵循了Android的UI设计方式，相当于Android UI的简化版本 "},"zh-cn/funcs/ui-js-inter.html":{"url":"zh-cn/funcs/ui-js-inter.html","title":"JS编写UI","keywords":"","body":"说明 本章节主要讲述JS与UI元素进行交互 和UI交互的的js模块对象统一以 ui开头，例如 ui.toast(\"msg\") 如何使用 在工程的layout文件夹下新建一个ui.js文件，内容为 function main(){ ui.toast(\"我是JS控制的UI\"); } main(); 加载layout的main.xml文件并展示出来，内容为 function main(){ ui.toast(\"我是JS控制的UI\"); ui.layout(\"标签1\",\"main.xml\"); } main(); 以上的操作即可完成一个简单的展示main.xml布局的操作 高级操作 编写一个ui.js /** * 该文件由EasyClick开发工具自动创建 */ function main() { ui.toast(\"我是ui的Toast函数\"); var set = ui.layout(\"参数设置\", \"main.xml\"); ui.layout(\"其他说明\", \"main2.xml\"); ui.logd(\"设置UI结果: \" + set); //Switch 开关按钮的用法 var auto_env = ui.getViewValue(ui.auto_env); ui.logd(\"tag为 auto_env 的值: \" + auto_env); //开关按钮的事件 ui.setEvent(ui.auto_env, \"checkedChange\", function (view, isChecked) { ui.logd(\"tag为 auto_env isChecked \" + isChecked); if (isChecked) { startAutoEnv(); } }); if (ui.isServiceOk()) { ui.auto_env.setChecked(true); } else { ui.auto_env.setChecked(false); } //EditText 编辑框的用法 var name = ui.getViewValue(ui.name); ui.logd(\"tag为name的值: \" + name); ui.name.setText(\"我是name的值\"); //Spinner 下拉选择框用法 var sex = ui.getViewValue(ui.sex); ui.logd(\"tag为 sex 的值: \" + sex); //下拉选择框的事件 ui.setEvent(ui.sex, \"itemSelected\", function (position, value) { ui.logd(\"tag为 sex itemSelected \" + value); }); //RadioButton 单选框用法 var three = ui.getViewValue(ui.three); ui.logd(\"tag为 three 的值: \" + three); //单选框的事件 ui.setEvent(ui.three, \"checkedChange\", function (view, isChecked) { ui.logd(\"tag为 three isChecked \" + isChecked); }); //CheckBox 复选框用法 var dance = ui.getViewValue(ui.dance); ui.logd(\"tag为 dance 的值: \" + dance); //复选框的事件 ui.setEvent(ui.dance, \"checkedChange\", function (view, isChecked) { ui.logd(\"tag为 dance isChecked \" + isChecked); }); //saveAllBtn 保存参数事件 ui.setEvent(ui.saveAllBtn, \"click\", function (view) { var s = ui.saveAllConfig(); ui.logd(\"保存所有参数结果 \" + s) }); //系统设置按钮 ui.setEvent(ui.systemSetting, \"click\", function (view) { ui.openECSystemSetting(); }); //启动脚本按钮 ui.setEvent(ui.startBtn, \"click\", function (view) { ui.start(); }); //启动环境按钮 ui.setEvent(ui.envBtn, \"click\", function (view) { //异步启动环境，如果成功了就设置auto_env 按钮的状态 startAutoEnv(); }); //获取所有的UI参数 ui.logd(\"获取所有的UI参数：\" + ui.getConfigJSON()); //设置值的用法，这里先注释掉 // ui.setViewValue(ui.name, \"我是设置的\"); // ui.setViewValue(ui.auto_env, false); // ui.setViewValue(ui.sex, \"男生|女生\"); // ui.setViewValue(ui.three, true); // ui.setViewValue(ui.dance, false) //内存临时存储变量和数据 ui.putShareData(\"nameVar\",ui.name); ui.putShareData(\"value\",\"我是value\"); } function startAutoEnv() { ui.startEnvAsync(function (r) { ui.logd(\"启动环境结果: \" + r); ui.auto_env.setChecked(r); }); } main(); 脚本如何与JS交互 以下代码是在js/main.js中运行的 function main() { //脚本获取UI中的对象，肯定是要先有界面才行 //这里可以直接引用UI对象 //假设在xml中，我们配置一个一个tag=name 的输入框，EditText //获取UI模块设置的变量和数据 logd(ui.getShareData(\"nameVar\")) logd(ui.getShareData(\"value\")) //第一种方式，变量引用 //重置JS变量 ui.resetUIVar() //打印一下UI中的name变量 logd(\"ui.name \"+ui.name) if (ui.name) { //UI主线程中处理 getHandler().post(function (){ ui.name.setText(\"Fsdafsadfsa\") ui.logd(\"输入框内容为 : \"+ui.name.getEditableText()); }); } sleep(2000); //第二种方式， findViewByTag var name = ui.findViewByTag(\"name\"); if (name) { //UI主线程中处理 getHandler().post(function (){ name.setText(\"懵逼了\") ui.logd(\"输入框内容为 : \"+name.getEditableText()); }); } sleep(5000); } main(); 功能函数说明 消息类 消息函数 toast 显示Toast信息 @param msg 信息 function main(){ ui.toast(\"我是JS控制的UI\"); } main(); 日志函数 logd 调试日志打印 @param msg 打印的消息 function main(){ ui.logd(\"我是消息\"); } main(); 布局UI类 设置布局 layout 创建一个布局并设置到当前的页面中 @param name tab标签的名称 @param content 可以是layout文件夹中的文件名称，也可以直接是xml文件的内容 @return 布尔型 true代表成功， false代表失败 function main() { // xml文件在layout文件夹下 var u1=ui.layout(\"参数说明\", \"main.xml\"); var u2=ui.layout(\"其他说明\", \"main2.xml\"); ui.logd(\"参数说明创建结果: \" + u1); ui.logd(\"其他说明创建结果: \" + u2); } main(); 解析布局 parseView 解析布局并返回 @param content 可以是layout文件夹中的文件名称，也可以直接是xml文件的内容 @return View android的View对象，解析有问题就是null function main() { // xml文件在layout文件夹下 var u1=ui.parseView(\"main.xml\"); ui.logd(\"创建结果: \" + u1); } main(); 查找视图 resetUIVar 将所有的tag转换成UI的属性直接调用 function main() { // xml文件在layout文件夹下 var u1=ui.layout(\"参数说明\", \"main.xml\"); var u2=ui.layout(\"其他说明\", \"main2.xml\"); ui.resetUIVar(); } main(); 查找视图 findViewByTag 通过tag查找到一个视图 @param tag 标签值 @return View android原生的View对象 function main() { // xml文件在layout文件夹下 var u1=ui.layout(\"参数说明\", \"main.xml\"); var u2=ui.layout(\"其他说明\", \"main2.xml\"); //查找tag=name的视图 var nameView =ui.findViewByTag(\"name\"); ui.logd(\"name view is:\"+nameView); } main(); 保存数据到存储区 putShareData 存储数据到存储区中，脚本可以使用,可用于存储变量和数据 @param key 键 @param value 值 @return 布尔型 true成功 false失败 function main() { // xml文件在layout文件夹下 var u1=ui.layout(\"参数说明\", \"main.xml\"); var u2=ui.layout(\"其他说明\", \"main2.xml\"); //保存到存储区 ui.putShareData(\"name\",\"我是临时数据\"); } main(); 从存储区读取数据 getShareData 从存储区获取在UI模块存储的数据 @param key 键 @return 存储的数据 function main() { // xml文件在layout文件夹下 var u1=ui.layout(\"参数说明\", \"main.xml\"); var u2=ui.layout(\"其他说明\", \"main2.xml\"); //从存储区读取数据 var d= ui.getShareData(\"name\"); logd(\"d => \"+d) } main(); 从存储区清空数据 clearAllShareData 清理所有存储区的数据 @return true 或者 false function main() { ui.clearAllShareData(); } main(); 设置事件 setEvent 设置事件 @param view 要设置事件的视图，可以是事件的tag值 @param eventType 时间类型： click：点击，checkedChange：单选和多选按钮的选中状态改变事件，itemClick：列表的项目点击，itemSelected：列表的项目选中 @param eventCallback 事件回调函数 @return 布尔型 true代表设置成功， false代表设置失败 function main() { // xml文件在layout文件夹下 var u1=ui.layout(\"参数说明\", \"main.xml\"); var u2=ui.layout(\"其他说明\", \"main2.xml\"); //下拉选择框的事件 ui.setEvent(ui.sex, \"itemSelected\", function (position, value) { ui.logd(\"tag为 sex itemSelected \" + value); }); ui.setEvent(ui.dance, \"checkedChange\", function (view, isChecked) { ui.logd(\"tag为 dance isChecked \" + isChecked); }); ui.setEvent(ui.startBtn, \"click\", function (view) { ui.start(); }); } main(); 获取根视图 getRootView 取得当前的根视图对象，因为有可能是多标签的页面，返回的有可能是个集合 @return View 对象列表 function main() { // xml文件在layout文件夹下 var u1=ui.layout(\"参数说明\", \"main.xml\"); var u2=ui.layout(\"其他说明\", \"main2.xml\"); //下拉选择框的事件 var views= ui.getRootView(); ui.logd(\"views \"+views) for (var i = 0; i \"+value) } } main(); 设置视图值 setViewValue 设置视图的值 @param tagOrView 视图的tag或者视图对象 @param value 值，字符串或者是布尔型 @return 布尔型 true代表成功 false代表失败 function main() { // xml文件在layout文件夹下 var u1=ui.layout(\"参数说明\", \"main.xml\"); var u2=ui.layout(\"其他说明\", \"main2.xml\"); //ui.name 是值xml中tag=name的视图对象 ui.setViewValue(ui.name,\"我是设置的名称\") } main(); 获取视图值 getViewValue 取得视图的值 @param tagOrView 视图的tag或者视图对象 @return 字符串或者布尔型 function main() { // xml文件在layout文件夹下 var u1=ui.layout(\"参数说明\", \"main.xml\"); var u2=ui.layout(\"其他说明\", \"main2.xml\"); //ui.name 是值xml中tag=name的视图对象 ui.setViewValue(ui.name,\"我是设置的名称\"); var v = ui.getViewValue(ui.name); ui.logd(\"获取name的值为: \"+v); } main(); 取得UI配置值 getConfigJSON 取得所有UI配置 @return JSON字符串 function main() { // xml文件在layout文件夹下 var u1=ui.layout(\"参数说明\", \"main.xml\"); var u2=ui.layout(\"其他说明\", \"main2.xml\"); ui.setViewValue(ui.name,\"我是name\"); //保存所有的值 ui.saveAllConfig(); var data = ui.getConfigJSON(); ui.logd(\"data \"+data); data= JSON.parse(data); //打印name的值，如果没有值要先保存一下 ui.logd(data.name); } main(); 取得单个UI值 getConfig 取得单个UI配置项 @param key 配置的key @return 字符串 function main() { // xml文件在layout文件夹下 var u1=ui.layout(\"参数说明\", \"main.xml\"); var u2=ui.layout(\"其他说明\", \"main2.xml\"); ui.setViewValue(ui.name,\"我是name\"); //保存所有的值 ui.saveAllConfig(); //单独保存某些值 ui.saveConfig(\"sex\",\"女同学\"); ui.saveConfig(\"music\",true); var data = ui.getConfigJSON(); ui.logd(\"data \"+data); data= JSON.parse(data); //打印name的值，如果没有值要先保存一下 ui.logd(data.name); //获取单个值 ui.logd(ui.getConfig(\"name\")); } main(); 保存所有UI值 saveAllConfig 根据设置的tag，保存所有配置 @return 布尔型 true 保存成功，false 保存失败 function main() { // xml文件在layout文件夹下 var u1=ui.layout(\"参数说明\", \"main.xml\"); var u2=ui.layout(\"其他说明\", \"main2.xml\"); ui.setViewValue(ui.name,\"我是name\"); //保存所有的值 ui.saveAllConfig(); //单独保存某些值 ui.saveConfig(\"sex\",\"女同学\"); ui.saveConfig(\"music\",true); var data = ui.getConfigJSON(); ui.logd(\"data \"+data); data= JSON.parse(data); //打印name的值，如果没有值要先保存一下 ui.logd(data.name); } main(); 保存单个UI值 saveConfig 保存UI参数值 @param key UI的key @param value UI的值 @return 布尔型 true代表成功 false代表失败 function main() { // xml文件在layout文件夹下 var u1=ui.layout(\"参数说明\", \"main.xml\"); var u2=ui.layout(\"其他说明\", \"main2.xml\"); ui.setViewValue(ui.name,\"我是name\"); //保存所有的值 ui.saveAllConfig(); //单独保存某些值 ui.saveConfig(\"sex\",\"女同学\"); ui.saveConfig(\"music\",true); var data = ui.getConfigJSON(); ui.logd(\"data \"+data); data= JSON.parse(data); //打印name的值，如果没有值要先保存一下 ui.logd(data.name); } main(); 读取图像资源 resResAsDrawable 读取IEC包中的res文件夹某个文件资源，并变成android的Drawable对象返回 @param path res文件夹中的资源文件路径 @return Drawable 图像对象或者null function main() { // xml文件在layout文件夹下 var u1=ui.layout(\"参数说明\", \"main.xml\"); var u2=ui.layout(\"其他说明\", \"main2.xml\"); //checkbox.png 存放在res文件夹下 var bg = ui.resResAsDrawable(\"checkbox.png\"); //设置动态背景色 ui.music.setBackgroundDrawable(bg); //设置按钮的背景 ui.music.setButtonDrawable(bg); } main(); 对话框 alert alert，弹窗 @param map 例如{\"title\":\"\"},key的固定只有 title 标题 msg: 消息 cancelText: 取消按钮文字 okText: 确定按钮文字 cancelable: 是否可取消 @param okBtnCallback 点击确认按钮的回调 @param cancelBtnCallback 点击取消按钮的回调 @param dismissListener 对话框消失的回调 @return 布尔型 true 代表成功，false 代表失败 function main() { var p = { \"title\": \"沙雕确认\", \"msg\": \"你是沙雕吗？\", \"cancelable\": true, \"cancelText\": \"不是\", \"okText\": \"我是\" }; ui.alert(p, function (dialog, v) { logd(\"ok btn click : \") //让对话消失掉 dialog.doDismiss(); return true; }, function (dialog, v) { logd(\"cancel btn click \") //让对话消失掉 dialog.doDismiss(); return true; }, function () { logd(\"mission btn click \") return true; }); } main(); inputDialog inputDialog 输入框弹窗 @param map 例如{\"title\":\"\"},key的固定只有 title 标题 msg: 消息 cancelText: 取消按钮文字 okText: 确定按钮文字 cancelable: 是否可取消 @param okBtnCallback 点击确认按钮的回调 @param cancelBtnCallback 点击取消按钮的回调 @param dismissListener 对话框消失的回调 @return 布尔型 true 代表成功，false 代表失败 function main() { var p = { \"title\": \"沙雕确认\", \"msg\": \"你是沙雕吗？\", \"cancelable\": true, \"cancelText\": \"不是\", \"okText\": \"我是\" }; ui.inputDialog(p, function (dialog, v,text) { //text 是输入的文字 logd(\"ok btn click : \"+text) //让对话消失掉 dialog.doDismiss(); return true; }, function (dialog, v,text) { logd(\"cancel btn click \"+text) //让对话消失掉 dialog.doDismiss(); return true; }, function () { logd(\"mission btn click \") return true; }); } main(); customDialog 自定义对话框 @param params 例如{\"cancelable\":\"\"},key的固定只有 fullScreen 是否全屏 cancelable: 是否可取消 @param view 原生的视图 @param onViewBind 视图绑定时候回调函数 @param dismissListener 对话框消失的回调 @return 布尔型 true 代表成功，false 代表失败 function main() { //用安卓原生的控件 importPackage(android.widget) var textView = new TextView(ui.getContext()); textView.setText(\"sdfasfsad\"); // 使用xml解析出来的控件 var textView = ui.parseView(\"main2.xml\"); ui.customDialog({ \"fullScreen\": true, \"cancelable\": true }, textView, function (dialog, v) { //这里面可以拿到视图对象，然后进行设置各种事件 }, function () { logd(\"dsssss\") }) } main(); 浮窗类 浮窗权限 hasFloatViewPermission 是否有浮窗权限 @return 布尔型 true代表有权限 false代表无权限 function main() { var r = ui.hasFloatViewPermission(); if (!r) { var req = ui.requestFloatViewPermission(10000); ui.logd(\"申请浮窗权限: \"+req); } r = ui.hasFloatViewPermission(); ui.logd(\"是否有浮窗权限: \"+r); } main(); 请求浮窗权限 requestFloatViewPermissionAsync 异步请求浮窗权限 @param timeout 超时时间 @param callback 回调函数 @return 布尔型 true代表有权限 false代表无权限 function main() { var r = ui.hasFloatViewPermission(); if (!r) { ui.requestFloatViewPermissionAsync(20000,function(r){ ui.logd(\"申请浮窗权限: \"+r); }); } r = ui.hasFloatViewPermission(); ui.logd(\"是否有浮窗权限: \"+r); } main(); 展示控制浮窗 showCtrlWindow 展示控制浮窗 @return 布尔型 true代表成功，false代表失败 function main() { var r = ui.hasFloatViewPermission(); ui.logd(\"是否有浮窗权限:\"+r) if (!r) { return } //展示浮窗 ui.showCtrlWindow(); ui.logd(\"显示消息\") //3秒后在UI线程消失掉 ui.getHandler().postDelayed(function (){ ui.closeCtrlWindow(); },3000); } main(); 关闭控制浮窗 closeCtrlWindow 关闭控制浮窗 @return 布尔型 true代表成功，false代表失败 function main() { var r = ui.hasFloatViewPermission(); ui.logd(\"是否有浮窗权限:\"+r) if (!r) { return } //展示浮窗 ui.showCtrlWindow(); ui.logd(\"显示消息\") //3秒后在UI线程消失掉 ui.getHandler().postDelayed(function (){ ui.closeCtrlWindow(); },3000); } main(); 展示日志浮窗 showLogWindow 显示日志浮窗 @return 布尔型 true代表成功，false代表失败 function main() { var r = ui.hasFloatViewPermission(); ui.logd(\"是否有浮窗权限:\"+r) if (!r) { return } //展示浮窗 ui.showLogWindow(); ui.logd(\"显示消息\") //3秒后在UI线程消失掉 ui.getHandler().postDelayed(function (){ ui.closeLogWindow(); },3000); } main(); 关闭日志浮窗 closeLogWindow 关闭日志浮窗 @return 布尔型 true代表成功，false代表失败 function main() { var r = ui.hasFloatViewPermission(); ui.logd(\"是否有浮窗权限:\"+r) if (!r) { return } //展示浮窗 ui.showLogWindow(); ui.logd(\"显示消息\") //3秒后在UI线程消失掉 ui.getHandler().postDelayed(function (){ ui.closeLogWindow(); },3000); } main(); 脚本启动 是否是无障碍模式 isAccMode 是否是无障碍运行模式 @return 布尔型 true 是 false 否 function main() { ui.logd(\"无障碍模式: \"+ui.isAccMode()); ui.logd(\"代理模式: \"+ui.isAgentMode()); // 设置运行模式 ui.setRunningMode(1); ui.logd(\"无障碍模式: \"+ui.isAccMode()); ui.logd(\"代理模式: \"+ui.isAgentMode()); } main(); 是否是代理模式 isAgentMode 是否是代理运行模式 @return 布尔型 true 是 false 否 function main() { ui.logd(\"无障碍模式: \"+ui.isAccMode()); ui.logd(\"代理模式: \"+ui.isAgentMode()); // 设置运行模式 ui.setRunningMode(1); ui.logd(\"无障碍模式: \"+ui.isAccMode()); ui.logd(\"代理模式: \"+ui.isAgentMode()); } main(); 自动化服务是否正常 isServiceOk 自动化服务是否正常 @return 布尔型 true 是 false 否 function main() { ui.logd(\"无障碍模式: \"+ui.isAccMode()); ui.logd(\"代理模式: \"+ui.isAgentMode()); // 设置运行模式 ui.setRunningMode(1); ui.logd(\"无障碍模式: \"+ui.isAccMode()); ui.logd(\"代理模式: \"+ui.isAgentMode()); var ok = ui.isServiceOk(); if (!ok) { ui.startEnvAsync(function (r) { ui.logd(\"启动环境结果: \" + r); }); } } main(); 设置运行模式 setRunningMode 设置运行模式 @param mode 1 代表是代理模式 2 代表无障碍模式 @return 布尔型 true 是 false 否 function main() { ui.logd(\"无障碍模式: \"+ui.isAccMode()); ui.logd(\"代理模式: \"+ui.isAgentMode()); // 设置运行模式 ui.setRunningMode(1); ui.logd(\"无障碍模式: \"+ui.isAccMode()); ui.logd(\"代理模式: \"+ui.isAgentMode()); } main(); 异步启动自动化环境 startEnvAsync 启动环境 @return 布尔型 true代表启动成功，false代表启动失败 function main() { var ok = ui.isServiceOk(); if (!ok) { ui.startEnvAsync(function (r) { ui.logd(\"启动环境结果: \" + r); }); } } main(); 启动测试脚本 start 启动脚本 @return 布尔型 true代表启动成功，false代表启动失败 function main() { ui.layout(\"参数设置\", \"main.xml\"); //xml中有个tag=startBtn的按钮 //启动脚本按钮 ui.setEvent(ui.startBtn, \"click\", function (view) { ui.start(); }); } main(); 停止测试脚本 stopTask 停止测试脚本 @return 布尔型 true代表启动成功，false代表启动失败 function main() { ui.layout(\"参数设置\", \"main.xml\"); //xml中有个tag=stopBtn的按钮 //启动脚本按钮 ui.setEvent(ui.stopBtn, \"click\", function (view) { ui.stopTask(); }); } main(); 定时任务 开启定时任务 startJob 开启一个定时脚本任务 @param tag 任务的唯一标示，不能为空，脚本中可以使用readConfigString(\"jobTaskTag\")获取当前tag值，判断是那个任务过来执行的 @param execTime 定时时间格式: 2020-04-17 19:20:00，或者直接是秒数字，例如 3，代表3秒后 @param cancelBeforeRunning @return 整型 jobid function main() { var set = ui.layout(\"参数设置\", \"main.xml\"); //按照日志定时的任务 var time=\"2020-05-15 15:47:00\"; var tag=\"job1\"; var jobid = ui.startJob(tag,time,true); ui.logd(\"按照日志定时的任务:\"+jobid) //按照多少秒执行 var time2=\"10\"; var tag2=\"job2\"; var jobid2 = ui.startJob(tag2,time2,false); ui.logd(\"按照多少秒执行:\"+jobid2) var tags=ui.getAllJobTag(); ui.logd(\"定时任务的标签:\"+tags) //取消任务 ui.cancelAllJob(); //按照标签取消任务 ui.cancelJob(\"job2\"); } main(); 取消定时任务 cancelJob 取消指定标签的任务 @param tag 标签 @return 布尔型 true代表成功，false代表失败 function main() { var set = ui.layout(\"参数设置\", \"main.xml\"); //按照日志定时的任务 var time=\"2020-05-15 15:47:00\"; var tag=\"job1\"; var jobid = ui.startJob(tag,time,true); ui.logd(\"按照日志定时的任务:\"+jobid) //按照多少秒执行 var time2=\"10\"; var tag2=\"job2\"; var jobid2 = ui.startJob(tag2,time2,false); ui.logd(\"按照多少秒执行:\"+jobid2) var tags=ui.getAllJobTag(); ui.logd(\"定时任务的标签:\"+tags) //取消任务 ui.cancelAllJob(); //按照标签取消任务 ui.cancelJob(\"job2\"); } main(); 取消所有定时任务 cancelAllJob 取消所有的定时任务 @return 布尔型 true代表成功，false代表失败 function main() { var set = ui.layout(\"参数设置\", \"main.xml\"); //按照日志定时的任务 var time=\"2020-05-15 15:47:00\"; var tag=\"job1\"; var jobid = ui.startJob(tag,time,true); ui.logd(\"按照日志定时的任务:\"+jobid) //按照多少秒执行 var time2=\"10\"; var tag2=\"job2\"; var jobid2 = ui.startJob(tag2,time2,false); ui.logd(\"按照多少秒执行:\"+jobid2) var tags=ui.getAllJobTag(); ui.logd(\"定时任务的标签:\"+tags) //取消任务 ui.cancelAllJob(); //按照标签取消任务 ui.cancelJob(\"job2\"); } main(); 所有定时任务标签 getAllJobTag 获取所有定时任务TAG @return JSON字符串 function main() { var set = ui.layout(\"参数设置\", \"main.xml\"); //按照日志定时的任务 var time=\"2020-05-15 15:47:00\"; var tag=\"job1\"; var jobid = ui.startJob(tag,time,true); ui.logd(\"按照日志定时的任务:\"+jobid) //按照多少秒执行 var time2=\"10\"; var tag2=\"job2\"; var jobid2 = ui.startJob(tag2,time2,false); ui.logd(\"按照多少秒执行:\"+jobid2) var tags=ui.getAllJobTag(); ui.logd(\"定时任务的标签:\"+tags) //取消任务 ui.cancelAllJob(); //按照标签取消任务 ui.cancelJob(\"job2\"); } main(); 其他扩展 监听Activity 状态 onActivityEvent 监听UI所在的activity事件 @param eventType 事件类型，分别为：onResume：Activity恢复时， onPause: Activity暂停时， onStop：Activity停止时， onDestroy：Activity销毁时 @param callback 回调函数 function main() { //监听Activity的事件设置 ui.onActivityEvent(\"onResume\", function (eventType) { // 可以在这里判断服务是否正常 ui.logd(\"activity onResume \" + ui.isServiceOk()); }); ui.onActivityEvent(\"onPause\", function (eventType) { ui.logd(\"activity onPause\"); }); ui.onActivityEvent(\"onStop\", function (eventType) { ui.logd(\"activity onStop\"); }); ui.onActivityEvent(\"onDestroy\", function (eventType) { ui.logd(\"activity onDestroy\"); }); } main(); UI对应的Activity getActivity 取得当前的activity对象 @return Activity 对象或者null function main() { var activity=ui.getActivity(); ui.logd(\"activity \"+activity); //android context对象也是自带的 importPackage(android.widget); importPackage(android.graphics); //直接使用java对象 var tv = new android.widget.TextView(context); tv.setText(\"我是js和java交互的文本对象\"); tv.setTextColor(Color.parseColor(\"#888888\")) activity.setContentView(tv); } main(); 原生的Handler getHandler 取得当前的Handler对象 @return Handler 对象或者null function main() { //展示浮窗 ui.showLogWindow(); ui.logd(\"显示消息\") //3秒后在UI线程消失掉 ui.getHandler().postDelayed(function (){ ui.closeLogWindow(); },3000); } main(); 设置EC的系统参数 setECSystemConfig 设置EC的系统参数 @param params map形式例如 {\"running_mode\":\"无障碍\"}, { \"node_service\":\"需要\", \"proxy_service\":\"不需要\", \"running_mode\":\"无障碍\", \"auto_start_service\":\"是\", \"volume_start_tc\":\"否\", \"log_float_window\":\"否\", \"ctrl_float_window\":\"否\" } 参数解释有： node_service : 是否需要启动节点获取服务 值有 需要，不需要两种 proxy_service : 是否需要启动底层代理服务 值有 需要，不需要两种 running_mode : 手势执行服务 值有 无障碍，代理两种 auto_start_service : 开机启动服务 值有 是，否 两种 volume_start_tc : 音量键启停 值有 是，否 两种 log_float_window : 日志悬浮窗展示 值有 是，否 两种 ctrl_float_window : 启停控制悬浮窗展示 值有 是，否 两种 * @return 布尔型 true 是 false 否 function main(){ var m = { \"node_service\":\"需要\", \"proxy_service\":\"不需要\", \"running_mode\":\"无障碍\", \"auto_start_service\":\"是\", \"volume_start_tc\":\"否\", \"log_float_window\":\"否\", \"ctrl_float_window\":\"否\" }; ui.setECSystemConfig(m); } main(); 打开EC系统设置 openECSystemSetting 打开EC的系统设置 @return 布尔型 true代表成功 false代表失败 function main() { ui.openECSystemSetting(); } main(); 打开其他应用程序 openActivity 打开一个activity，通过map参数 @param map 例如{\"action\":\"\"},key的固定只有 action, uri,pkg,className,flag,其他的都是参数了 @return 布尔型 true 代表成功，false 代表失败 function main() { //打开安装包界面 var m ={ \"action\":\"android.intent.action.VIEW\", \"uri\":\"file:///sdcard/a.apk\", \"type\":\"application/vnd.android.package-archive\" }; var x = ui.openActivity(m); ui.logd(\"x \"+x); var map={ \"uri\":\"xx://xx/live/6701887916223941379\", }; ui.openActivity(map); } main(); "},"zh-cn/funcs/ui-js-template.html":{"url":"zh-cn/funcs/ui-js-template.html","title":"模板式UI","keywords":"","body":"模板创建 如果不需要和JS进行交互的情况下，可以直接使用模板进行创建 模板创建只需要在项目工程的layout文件夹下创建xml 文件，并编写对应的XML代码即可 例如: 多tab标签支持 只要在工程的layout工程下新建一个ui.js文件即可 内容是 function main(){ ui.layout(\"参数配置\",\"main.html\"); ui.layout(\"注册使用\",\"reg.html\"); ui.layout(\"使用说明\",\"intr.html\"); } main(); 支持的原生视图请查看 原生UI控件 章节 "},"zh-cn/funcs/ui-native-view.html":{"url":"zh-cn/funcs/ui-native-view.html","title":"原生UI控件","keywords":"","body":"支持以下视图 LinearLayout 线性布局 FrameLayout 帧布局 RelativeLayout 绝对布局 ScrollView 滚动框 View视图 Button 按钮 TextView 文本视图 EditText 输入框 CheckBox 复选框 RadioGroup布局 RadioButton 单选框 Spinner 下拉选择框 WebView内嵌浏览器 ImageView图像 CardView卡片布局 Swtich开关按钮 公有属性 属性名 说明 可选值 layout_width 宽度 wrap_content: 和自身内容一样的长度 match_parent:和父组件一样的长度具体数字+dp layout_height 高度 wrap_content: 和自身内容一样的长度 match_parent:和父组件一样的长度具体数字+dp background 背景色 16进制的背景色，例如#FFFFFF或者#FFFFFFFF tag 标签 中英文都可，在代码中可以通过tag获取对应的值 visibility 是否可展示 gone:不展示visible:展示invisible:不展示但是占用空间 clickable 是否可点击 true: 可点击 false: 不可点击 enable 是否启用 true: 启用 false: 禁用 minHeight 最小高度 具体数字+dp minWidth 最小宽度 具体数字+dp paddingLeft 左内边距 具体数字+dp paddingTop 上内边距 具体数字+dp paddingRight 右内边距 具体数字+dp paddingBottom 下内边距 具体数字+dp padding 上下左右内边距 具体数字+dp layout_gravity 自身相当于父容器的对齐方式 用法参考topbottomleftrightcenter_verticalfill_verticalcenter_horizontalfill_horizontalcenterfillclip_verticalclip_horizontal layout_margin 上下左右外边距 具体数字+dp layout_marginLeft 左外边距 具体数字+dp layout_marginRight 右外边距 具体数字+dp layout_marginTop 上外边距 具体数字+dp layout_marginBottom 下外边距 具体数字+dp cornerRadius 视图的圆角度数 具体数字+dp UI高度和宽度解释 属性为：layout_width, layout_height match_parent 填充满父容器 wrap_content 以自身实际宽度为准 数字型，例如：12dp，代表12个dp宽度，dp是android的宽度单位 UI界面参数读取 参考 全局模块UI参数读取 "},"zh-cn/funcs/ui/linearlayout.html":{"url":"zh-cn/funcs/ui/linearlayout.html","title":"LinearLayout线性布局","keywords":"","body":"说明 LinearLayout，中文意思就是线性布局， 在实际开发中比较常用的布局，它主要以水平和垂直的方式来显示界面中的控件。 在线性布局中，线性布局管理器允许为每一个子视图指定一个weight属性，以控制每一个子视图在空间内的大小。 而线性布局中的orientation属性则是用于控制控件的排列方向。 android:orientation=\"vertical\"属性将其指定为垂直线性排列； android:orientation=\"horizontal\"属性将其指定为水平线性排列； 使用示例 属性说明 公有属性 请参考 公有属性 私有属性 属性名 说明 可选值 orientation 方向 vertical:垂直 horizontal:水平 "},"zh-cn/funcs/ui/framelayout.html":{"url":"zh-cn/funcs/ui/framelayout.html","title":"FrameLayout帧布局","keywords":"","body":"说明 FrameLayout，帧布局是最为简单的一种布局，该布局为每个加入其中的控件创建一个空白区域，称为一帧，每个控件占据一帧。采用帧布局时，所有控件都默认显示在屏幕左上角，并按照先后放入的顺序重叠摆放，先放入的将会在最底层，后放入的控件显示在最顶层。帧布局使用于图层设计。 使用示例 属性说明 公有属性 请参考 公有属性 私有属性 属性名 说明 可选值 layout_weight 子元素权重 数字当父级为LinearLayout的时候，子控件可以设置权重 "},"zh-cn/funcs/ui/relativelayout.html":{"url":"zh-cn/funcs/ui/relativelayout.html","title":"RelativeLayout绝对布局","keywords":"","body":"说明 相对布局是通过相对定位的方式制定控件位置，即以其他的控件或父容器为参照物，摆放控件位置。在设计相对布局时要遵循控件之间的依赖关系，后放入的控件的位置要依赖于先放入的控件。 使用示例 属性说明 公有属性 请参考 公有属性 私有属性 属性名 说明 可选值 layout_weight 子元素权重 数字当父级为LinearLayout的时候，子控件可以设置权重 gravity 内部的控件对齐方式 用法参考topbottomleftrightcenter_verticalfill_verticalcenter_horizontalfill_horizontalcenterfillclip_verticalclip_horizontal "},"zh-cn/funcs/ui/scrollview.html":{"url":"zh-cn/funcs/ui/scrollview.html","title":"ScrollView滚动框","keywords":"","body":"说明 可以滚动的布局控件，子元素只能有一个 使用示例 属性说明 公有属性 请参考 公有属性 私有属性 属性名 说明 可选值 layout_weight 子元素权重 数字当父级为LinearLayout的时候，子控件可以设置权重 fillViewport 填充所有视图 true: 是 false:否 "},"zh-cn/funcs/ui/view.html":{"url":"zh-cn/funcs/ui/view.html","title":"View视图","keywords":"","body":"说明 View，最基础的视图 使用示例 属性说明 公有属性 请参考 公有属性 私有属性 无 "},"zh-cn/funcs/ui/button.html":{"url":"zh-cn/funcs/ui/button.html","title":"Button按钮","keywords":"","body":"说明 按钮 使用示例 属性说明 公有属性 请参考 公有属性 私有属性 属性名 说明 可选值 layout_weight 子元素权重 数字当父级为LinearLayout的时候，子控件可以设置权重 gravity 内部的控件对齐方式 用法参考topbottomleftrightcenter_verticalfill_verticalcenter_horizontalfill_horizontalcenterfillclip_verticalclip_horizontal text 按钮文字 字符串 textColor 文字颜色 16进制，例如#FFFFFF textSize 文字大小 具体数字+dp maxLength 文字最大长度 具体数字 "},"zh-cn/funcs/ui/textview.html":{"url":"zh-cn/funcs/ui/textview.html","title":"TextView文本","keywords":"","body":"说明 文本 使用示例 属性说明 公有属性 请参考 公有属性 私有属性 属性名 说明 可选值 layout_weight 子元素权重 数字当父级为LinearLayout的时候，子控件可以设置权重 gravity 内部的控件对齐方式 用法参考topbottomleftrightcenter_verticalfill_verticalcenter_horizontalfill_horizontalcenterfillclip_verticalclip_horizontal text 按钮文字 字符串 textColor 文字颜色 16进制，例如#FFFFFF textSize 文字大小 具体数字+dp maxLength 文字最大长度 具体数字 lines 行数 具体数字 maxLines 最大 具体数字 ellipsize 文字长度超过宽度时的显示方式 start:省略号显示在开头end:省略号显示在结尾middle:省略号显示在中间marquee:以横向滚动方式显示(需获得当前焦点时)none:不显示 "},"zh-cn/funcs/ui/edittext.html":{"url":"zh-cn/funcs/ui/edittext.html","title":"EditText输入框","keywords":"","body":"说明 文本输入框 使用示例 属性说明 公有属性 请参考 公有属性 私有属性 属性名 说明 可选值 layout_weight 子元素权重 数字当父级为LinearLayout的时候，子控件可以设置权重 gravity 内部的控件对齐方式 用法参考topbottomleftrightcenter_verticalfill_verticalcenter_horizontalfill_horizontalcenterfillclip_verticalclip_horizontal hit 输入提示 字符串 text 文字 字符串 textColor 文字颜色 16进制，例如#FFFFFF textSize 文字大小 具体数字+dp maxLength 文字最大长度 具体数字 lines 行数 具体数字 maxLines 最大 具体数字 ellipsize 文字长度超过宽度时的显示方式 start:省略号显示在开头end:省略号显示在结尾middle:省略号显示在中间marquee:以横向滚动方式显示(需获得当前焦点时)none:不显示 "},"zh-cn/funcs/ui/checkbox.html":{"url":"zh-cn/funcs/ui/checkbox.html","title":"CheckBox复选框","keywords":"","body":"说明 复选框 使用示例 属性说明 公有属性 请参考 公有属性 私有属性 属性名 说明 可选值 layout_weight 子元素权重 数字当父级为LinearLayout的时候，子控件可以设置权重 gravity 内部的控件对齐方式 用法参考topbottomleftrightcenter_verticalfill_verticalcenter_horizontalfill_horizontalcenterfillclip_verticalclip_horizontal checked 是否选择 true:选中 false:不选中 text 文字 字符串 textColor 文字颜色 16进制，例如#FFFFFF textSize 文字大小 具体数字+dp "},"zh-cn/funcs/ui/radiogroup.html":{"url":"zh-cn/funcs/ui/radiogroup.html","title":"RadioGroup布局","keywords":"","body":"说明 RadioGroup用于包裹RadioButton实现只选中一个的效果，继承LinearLayout，包含线性布局的属性 使用示例 属性说明 公有属性 请参考 公有属性 私有属性 属性名 说明 可选值 orientation 方向 vertical:垂直 horizontal:水平 "},"zh-cn/funcs/ui/radiobutton.html":{"url":"zh-cn/funcs/ui/radiobutton.html","title":"RadioButton单选框","keywords":"","body":"说明 单选框 使用示例 属性说明 公有属性 请参考 公有属性 私有属性 属性名 说明 可选值 layout_weight 子元素权重 数字当父级为LinearLayout的时候，子控件可以设置权重 gravity 内部的控件对齐方式 用法参考topbottomleftrightcenter_verticalfill_verticalcenter_horizontalfill_horizontalcenterfillclip_verticalclip_horizontal checked 是否选择 true:选中 false:不选中 text 文字 字符串 textColor 文字颜色 16进制，例如#FFFFFF textSize 文字大小 具体数字+dp "},"zh-cn/funcs/ui/spinner.html":{"url":"zh-cn/funcs/ui/spinner.html","title":"Spinner下拉选择框","keywords":"","body":"说明 下拉选框 使用示例 属性说明 公有属性 请参考 公有属性 私有属性 属性名 说明 可选值 layout_weight 子元素权重 数字当父级为LinearLayout的时候，子控件可以设置权重 gravity 内部的控件对齐方式 用法参考topbottomleftrightcenter_verticalfill_verticalcenter_horizontalfill_horizontalcenterfillclip_verticalclip_horizontal text 下拉文字 字符串多个下拉选项用竖线分隔，例如：选项1|选型2 textColor 文字颜色 16进制，例如#FFFFFF textSize 文字大小 具体数字+dp "},"zh-cn/funcs/ui/webview.html":{"url":"zh-cn/funcs/ui/webview.html","title":"WebView内嵌浏览器","keywords":"","body":"说明 WebView内嵌浏览器，支持H5和JS操作 使用示例 第一种 加载layout文件夹中的html 第二种网络上的html 属性说明 公有属性 请参考 公有属性 私有属性 属性名 说明 可选值 url 网页地址 支持layout内部的html，也支持http网络上的html "},"zh-cn/funcs/ui/imageview.html":{"url":"zh-cn/funcs/ui/imageview.html","title":"ImageView图像","keywords":"","body":"说明 图像 使用示例 属性说明 公有属性 请参考 公有属性 私有属性 属性名 说明 可选值 src 图像地址 字符串HTTP的URL或者IEC文件中的图像(@drawable/aaa这样的写法) scaleType 图像缩放方式 用法参考 / "},"zh-cn/funcs/ui/cardview.html":{"url":"zh-cn/funcs/ui/cardview.html","title":"CardView卡片布局","keywords":"","body":"说明 CardView 卡片布局 使用示例 属性说明 公有属性 请参考 公有属性 私有属性 属性名 说明 可选值 layout_weight 背景颜色 颜色的字符串例如 #888888 cardBackgroundColor 背景颜色 数字 例如 20dp cardCornerRadius 设置圆角大小 数字 例如 20dp cardElevation 设置z轴的阴影 数字 例如 20dp cardMaxElevation 设置z轴的最大高度值 数字 例如 20dp "},"zh-cn/funcs/ui/switch.html":{"url":"zh-cn/funcs/ui/switch.html","title":"Swtich开关按钮","keywords":"","body":"说明 开关按钮 使用示例 属性说明 公有属性 请参考 公有属性 私有属性 属性名 说明 可选值 layout_weight 子元素权重 数字当父级为LinearLayout的时候，子控件可以设置权重 gravity 内部的控件对齐方式 用法参考topbottomleftrightcenter_verticalfill_verticalcenter_horizontalfill_horizontalcenterfillclip_verticalclip_horizontal checked 是否选择 true:选中 false:不选中 text 文字 字符串 textColor 文字颜色 16进制，例如#FFFFFF textSize 文字大小 具体数字+dp "},"zh-cn/funcs/html-ui-custom.html":{"url":"zh-cn/funcs/html-ui-custom.html","title":"H5 UI定制","keywords":"","body":"说明 EasyClick 使用WebView支撑HTML的UI方式，并且扩展了JS方法，用于控制EC程序。 新建工程时候可以对应的模板，推荐使用Materialize模板，文档网址 http://www.materializecss.cn 也可以自己编写精美的HTML页面，更多JS方法的使用请参考模板中的用法 多tab标签支持 只要在工程的layout工程下新建一个ui.js文件即可 内容是 function main(){ ui.layout(\"参数配置\",\"main.html\"); ui.layout(\"注册使用\",\"reg.html\"); ui.layout(\"使用说明\",\"intr.html\"); } main(); 脚本如何与JS交互 编写xml视图 使用webview加载本地的main.html，tag=web 加载 xml 在ui.js中加载xml视图 function main(){ ui.layout(\"参数配置\",\"main.xml\"); } main(); html 代码 我是测试网页 //暴露给webview调用 function myalert() { alert(\"fdsafsad\"); //存储数据到内存中，给脚本读取 window.ec.putShareData(\"mymsg\",\"我是网页的临时数据\"); } //暴露给webview调用 带参数 function myalert(msg) { alert(\"我是msg \"+msg); } 脚本中调用 在js/main.js脚本中调用视图 function main() { //重置变量 ui.resetUIVar(); //读取UI存储到内存中的数据 logd(ui.getShareData(\"mymsg\")) logd(ui.web) //使用ui中 tag= web的视图 if (ui.web) { //myalert 是HTML中暴露的方法 //执行网页中的js方法 ui.web.quickCallJs(\"myalert();\"); ui.web.quickCallJs(\"myalert('bbbbb');\"); } } main(); 浏览器扩展方法 浏览器扩展的方法，主要用于网页和EC程序进行交互，并且这些方法只能在网页中调用才行 启动脚本 window.ec.start() 停止脚本 window.ec.stopTask() 隐藏开始按钮 window.ec.hideStartBtn() 显示开始按钮 window.ec.displayStartBtn() 获取所有配置的JSON字符串 var s= window.ec.getConfigJSON(); alert(s); 从配置文件获取单个配置的字符串 var s= window.ec.getConfig(\"name\"); alert(s); 保存单个配置到配置文件 var s= window.ec.saveConfig(\"name\",\"123\"); alert(s); 保存数据到存储区 这个数据是保存在内存中的 window.ec.putShareData(\"name\",\"123\"); 从存储区读取数据 这个数据是在内存中的 var d = window.ec.getShareData(\"name\"); alert(d); 清空存储区数据 这个数据是在内存中的 var d = window.ec.clearAllShareData(); alert(d); 打开EC的系统设置 window.ec.openECSystemSetting() 保存EC的系统参数 设置EC的系统参数 @param params map形式例如 {\"running_mode\":\"无障碍\"}, { \"running_mode\":\"无障碍\", \"auto_start_service\":\"是\", \"log_float_window\":\"否\", \"ctrl_float_window\":\"否\" } 参数解释有： running_mode : 手势执行服务 值有 无障碍，代理两种 auto_start_service : 开机启动服务 值有 是，否 两种 log_float_window : 日志悬浮窗展示 值有 是，否 两种 ctrl_float_window : 启停控制悬浮窗展示 值有 是，否 两种 * @return 布尔型 true 是 false 否 var m = { \"running_mode\":\"无障碍\", \"auto_start_service\":\"是\", \"log_float_window\":\"否\", \"ctrl_float_window\":\"否\" }; window.ec.setECSystemConfig(JSON.stringify(m)); 显示Toast消息 window.ec.toast(\"我是toast消息\") ; 显示日志消息窗口 window.ec.showLogWindow(); 关闭日志消息窗口 window.ec.closeLogWindow(); 显示日志消息 window.ec.logd(\"我是日志\"); 显示启停控制窗口 window.ec.showCtrlWindow(); 关闭启停控制窗口 window.ec.closeCtrlWindow(); 打开其他应用程序 openActivity //打开浏览器下载测试 var m ={ \"action\":\"android.intent.action.VIEW\", \"uri\":\"https://imtt.dd.qq.com/16891/apk/55259F8EF9824AF1BF80106B0E00BCD1.apk?\" }; var x = window.ec.openActivity(JSON.stringify(m)); window.ec.logd(\"x \"+x); var map={ \"uri\":\"xx://xx/live/6701887916223941379\", }; window.ec.openActivity(JSON.stringify(map)); 服务状态控制 是否是无障碍服务模式 var s = window.ec.isAccMode(); alert(s); 是否是代理服务模式 var s = window.ec.isAgentMode(); alert(s); 无障碍服务是否已经启动 var s = window.ec.isAccServiceOk(); alert(s); 代理服务是否已经启动 var s = window.ec.isAgentServiceOk(); alert(s); 启动服务环境 var s = window.ec.startEnv(); alert(s); 悬浮窗控制 是否有悬浮窗权限 var s = window.ec.hasFloatViewPermission(); alert(s); 请求悬浮窗权限 //参数是超时时间，单位是秒 var s = window.ec.requestFloatViewPermission(10); alert(s); 展示浮窗 var m = { \"path\": \"main.html\", \"tag\": \"tag\", \"titleBg\": \"#888888\", \"x\": 10, \"y\": 10, \"w\": 100, \"h\": 200 }; var xd =window.ec.showFloatView(JSON.stringify(m)); alert(xd); 关闭浮窗 var m = { \"path\": \"main.html\", \"tag\": \"tag\", \"titleBg\": \"#888888\", \"x\": 10, \"y\": 10, \"w\": 100, \"h\": 200 }; var xd =window.ec.showFloatView(JSON.stringify(m)); setTimeout(function() { window.ec.closeFloatView(\"tag\"); },3000); alert(xd); 关闭所有浮窗，不包含日志悬浮窗 var m = { \"path\": \"main.html\", \"tag\": \"tag\", \"titleBg\": \"#888888\", \"x\": 10, \"y\": 10, \"w\": 100, \"h\": 200 }; var xd =window.ec.showFloatView(JSON.stringify(m)); setTimeout(function() { window.ec.closeAllFloatView(); },3000); alert(xd); 定时任务 开启一个定时任务 开启一个定时脚本任务 @param tag 任务的唯一标示，不能为空，脚本中可以使用readConfigString(\"jobTaskTag\")获取当前tag值，判断是那个任务过来执行的 @param execTime 定时时间格式: 2020-04-17 19:20:00，或者直接是秒数字，例如 3，代表3秒后 @param cancelBeforeRunning @return 整型 jobid var time=\"2020-04-17 09:00:00\"; var id =window.ec.startJob(\"task1\",time,true); alert(\"job id \"+id); 获取所有定时任务TAG var t =window.ec.getAllJobTag(); alert(\"job tags \"+t); 取消所有定时任务 var t =window.ec.cancelAllJob(); alert(\"job cancel \"+t); 取消指定TAG定时任务 //参数task1 是创建定时任务的tag值 var t =window.ec.cancelJob(\"task1\"); alert(\"job cancel \"+t); "},"zh-cn/hot-update.html":{"url":"zh-cn/hot-update.html","title":"热更新功能","keywords":"","body":"什么是热更新 热更新一般用于不用安装程序即可将关键的代码进行更新 EC的热更新主要用于更新打包后的自动化测试脚本 EC如何热更新 打开工程下面的update.json，内容如下: { \"update_url\": \"http://xxx.com/update\", \"version\": \"1.0.0\" } 参数解析 update_url: 代表服务端的更新接口，需要自己编写服务端接口 version: 代表当前脚本的版本号 EC 加载新包 客户端请求 以上配置好后，打包运行，程序会自动使用GET方式请求 update_url对应的地址并且会带上参数； 例如 ：http://xxx.com/update?version=1.0.0 请自行在服务端做版本比较 服务端返回 服务端返回格式如下： { \"download_url\": \"http://xxx.com/aaa.iec\", \"version\": \"1.1.0\", \"dialog\":true, \"msg\": \"优化部分问题\", \"force\": false } download_url： 代表新包的下载地址 version：代表新包的版本号 返回这样的格式的JSON后，EC会下载最新的IEC包并加载使用。 5.0.0.RC3 新增参数 dialog: 代表是否用对话框的形式展示，true 代表是对话框，false代表不是 msg: 对话框中要显示的消息 force : 代码对话框模式下是否强制更新，true 代表强制更新，无法取消，false 代表不是强制更新 "},"zh-cn/zk/zk.html":{"url":"zh-cn/zk/zk.html","title":"企业版中控接口","keywords":"","body":"什么是中控 中控平台是一个统一管理和控制设备的平台 中控对接 已有的中控平台如何对接到EC程序中? EC开放的接口均使用HTTP POST方式即可请求到，参数一律使用JSON，如果你不太理解POST JSON，请看这个文章： https://www.cnblogs.com/bookyao/p/12134438.html 以及java如何进行POST JSON: https://blog.csdn.net/qq_26975307/article/details/82713725 EC在手机端远程地址是什么 EC在手机端的端口是 20390 USB连接设备模式 如果是USB直接连接设备的，请使用adb forward命令将EC端口转发到电脑端口，教程：https://www.jianshu.com/p/63c4d5c31909 例如将设备的20390转发到电脑的20390端口上： adb -s 手机的序列号1 forward tcp:20390 tcp:20390 转发端口到电脑后，可以在浏览器中打开 http://127.0.0.1:20390 就可以看到OK几个字样，代表成功转发 如果有多台设备，可以将本地端口依次递增 adb -s 手机的序列号x forward tcp:20390 tcp:20390 adb -s 手机的序列号1 forward tcp:20391 tcp:20390 adb -s 手机的序列号2 forward tcp:20392 tcp:20390 adb -s 手机的序列号3 forward tcp:20393 tcp:20390 如何获取手机序列号教程 https://www.cnblogs.com/yjlch1016/p/8512592.html WIFI连接模式 如果中控和设备在同一局域网，可以直接找到手机IP，直接请求手机到20390端口 按键精灵调用 如果你使用按键精灵或者其他手机软件调用EC，可以直接在手机上请求 http://127.0.0.1:20390 如果是按键精灵调用EC，请使用开发工具打企业版本的APK包 接口返回 接口返回示例： { \"code\":1, \"msg\":\"\", \"data\":true } code： 代表服务接口是否正常，1 代表正常服务，0 代表失败，如果为0的情况下，请查看msg的消息 msg：接口返回的错误消息 data：实际执行函数的返回值，可能是字符串，布尔型，护着数据JSON数据，这个请根据实际接口返回进行处理 中控接口 EC状态控制接口 全局节点模块接口 日志接口 节点服务接口 点击动作接口 多点触摸动作接口 滑动动作接口 拖动动作接口 输入动作接口 节点操作接口 系统按键接口 通知栏接口 悬浮窗接口 代理事件模块接口 图色模块接口 - 开发中 设备模块接口 - 开发中 文件模块接口 - 开发中 网络模块接口 - 开发中 常用工具模块接口 - 开发中 Shell命令模块接口 Sqlite模块接口 - 开发中 "},"zh-cn/zk/zk-ec-state.html":{"url":"zh-cn/zk/zk-ec-state.html","title":"EC状态控制接口","keywords":"","body":"说明 这个接口主要用于控制EC运行脚本包，或者停止脚本运行的 请求地址接口为 /script 以下例子均为USB连接的情况下，设备接口转到本机的 20390端口为例，请求地址为 http://127.0.0.1:20390/script 以下的例子均是使用nodejs做post json请求，如果你使用其他语言，可以自行更改 run 运行脚本(POST上传文件) 运行脚本 var FormData = require('form-data'); var http = require('http'); var fs = require('fs'); // type =run 代表运行 var url=\"http://127.0.0.1:20390/script?type=run\"; var form = new FormData(); //远程端接收iec文件的key是 file form.append('file', fs.createReadStream('C:\\test.iec')); form.submit(url, function(err, res) { console.log(res); }); } run 运行脚本(GET方式) 运行脚本 const http = require(\"http\") // type =run 代表运行 // path 代表IEC脚本包在手机上的路径 var url=\"http://127.0.0.1:20390/script?type=run&path=/sdcard/a.iec\"; http.get(url, (res) => { console.log(`Got response: ${res}`); res.resume(); }).on('error', (e) => { console.log(`Got error: ${e.message}`); }); stop 停止脚本(GET方式) 停止脚本 const http = require(\"http\") // type =stop 停止 var url=\"http://127.0.0.1:20390/script?type=stop\"; http.get(url, (res) => { console.log(`Got response: ${res}`); res.resume(); }).on('error', (e) => { console.log(`Got error: ${e.message}`); }); "},"zh-cn/zk/zk-node.html":{"url":"zh-cn/zk/zk-node.html","title":"全局节点模块接口","keywords":"","body":"说明 全局节点接口包含了所有节点操作，对应的是 全局模块和全局快捷事件 请求地址接口为 /global 所有的JSON参数中的type字段，都是要调用的方法名称，请看实例 以下例子均为USB连接的情况下，设备接口转到本机的 20391端口为例，请求地址为 http://127.0.0.1:20391/global 以下的例子均是使用nodejs做post json请求，如果你使用其他语言，可以自行更改 "},"zh-cn/zk/global/zk-global-log.html":{"url":"zh-cn/zk/global/zk-global-log.html","title":"日志接口","keywords":"","body":"日志函数 toast 浮层消息 浮层消息 @param msg 消息字符串 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"toast\", \"msg\": \"我是消息\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); logd 调试消息 调试消息 @param msg 消息字符串 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"logd\", \"msg\": \"我是消息\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); logi 信息消息 信息消息 @param msg 消息字符串 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"logi\", \"msg\": \"我是消息\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); logw 警告消息 警告消息 @param msg 消息字符串 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"logw\", \"msg\": \"我是消息\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); loge 错误消息 错误消息 @param msg 消息字符串 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"loge\", \"msg\": \"我是消息\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); setSaveLog 保存日志 设置保存日志到手机操作 @param save 是否保存 @param path 自定义的文件夹 @param size 每个文件分隔的尺寸 @return 保存日志文件的目录 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"setSaveLog\", \"save\": true, \"path\": \"/sdcard/bbb/\", \"size\": 2048 }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); clearLog 清理日志 清除日志 @param lines 整型，要清除的行数，-1 代表全部清除 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"clearLog\", \"lines\": -1 }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); "},"zh-cn/zk/global/zk-node-service.html":{"url":"zh-cn/zk/global/zk-node-service.html","title":"节点服务接口","keywords":"","body":"节点服务相关 exit 退出脚本 退出脚本 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"exit\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); setGestureActionMode 手势模式事件的操作 设置各种手势模式事件的操作类型，默认是异步,目前只对无障碍模式有效 @param mode 1 代表异步，2代表同步 @param bool true代表成功 false代表失败 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"setGestureActionMode\", \"mode\": 2 }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); openECSystemSetting 打开EC设置 打开EC设置 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"openECSystemSetting\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); isAccMode 是否无障碍模式 是否无障碍模式 @return 布尔型，true代表是，false代表否 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"isAccMode\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); isAgentMode 是否代理模式 是否代理模式 @return 布尔型，true代表是，false代表否 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"isAgentMode\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); isServiceOk 节点服务是否正常 节点服务是否正常，不区分运行模式 @return 布尔型，true代表是，false代表否 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"isServiceOk\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); startEnv 启动环境 启动环境，最好先激活手机，这样会自动启动环境，且免root @return 布尔型，true代表是，false代表否 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"startEnv\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); setECSystemConfig 设置EC系统参数 设置EC系统参数 @param settings JSON内部属性解释: running_mode : 运行模式 值有 无障碍，代理两种 auto_start_service： 开机自启动 值有 是，否 两种 log_float_window : 日志悬浮窗展示 值有 是，否 两种 ctrl_float_window : 启停控制悬浮窗展示 值有 是，否 两种 @return 布尔型，true代表是，false代表否 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"setECSystemConfig\", \"settings\": {\"running_mode\": \"代理\", \"auto_start_service\": \"否\", \"log_float_window\": \"否\", \"ctrl_float_window\": \"否\"} }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); "},"zh-cn/zk/global/zk-global-click.html":{"url":"zh-cn/zk/global/zk-global-click.html","title":"点击动作接口","keywords":"","body":"点击动作接口 文档函数中如果有selectors 选择器数组，更多选择器属性，请查看选择器与节点属性 clickPoint 点击坐标 点击坐标 @param x x坐标 @param y y坐标 @return 布尔型，true代表成功 false代表失败 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"clickPoint\", \"x\": 200, \"y\": 200 }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); longClickPoint 长点击坐标 长点击坐标 @param x x坐标 @param y y坐标 @return 布尔型，true代表成功 false代表失败 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"longClickPoint\", \"x\": 200, \"y\": 200 }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); click 选择器点击 选择器点击 @param selectors 选择器数组，更多选择器属性，请查看选择器与节点属性 @return 布尔型，true代表成功 false代表失败 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"click\", \"selectors\": [{ \"text\": \"时钟\" }] }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); clickEx 无指针点击 执行条件：无障碍5.0以上或者手势执行为代理服务 无指针方式点击选择器，节点必须是可点击的才行 @param selectors 选择器对象 @return {boolean|布尔型} var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"clickEx\", \"selectors\": [{ \"clickable\": : true }] }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); longClick 长选择器点击 长选择器点击 @param selectors 选择器数组，更多选择器属性，请查看选择器与节点属性 @return 布尔型，true代表成功 false代表失败 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"longClick\", \"selectors\": [{ \"text\": \"时钟\" }] }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); longClickEx 无指针长点击 执行条件：无障碍5.0以上或者手势执行为代理服务 无指针方式长点击选择器，节点必须是可点击的才行 @param selectors 选择器对象 @return {boolean|布尔型} var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"longClickEx\", \"selectors\": [{ \"clickable\": true }] }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); "},"zh-cn/zk/global/zk-global-multitouch.html":{"url":"zh-cn/zk/global/zk-global-multitouch.html","title":"多点触摸动作接口","keywords":"","body":"多点触摸动作接口 multiTouch 多点触摸 多点触摸，用法和全局快捷事件-多点触摸相同 @param arrays 多点触摸的数组，请看实例 @param timeout 超时时间，单位毫秒 @return 布尔型，true代表成功 false代表失败 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var touch1 = [ {\"action\": 0, \"x\": 500, \"y\": 1200, \"pointer\": 1, \"delay\": 1}, {\"action\": 2, \"x\": 500, \"y\": 1100, \"pointer\": 1, \"delay\": 20}, {\"action\": 2, \"x\": 500, \"y\": 1000, \"pointer\": 1, \"delay\": 20}, {\"action\": 1, \"x\": 1, \"y\": 1, \"pointer\": 1, \"delay\": 20} ]; var touch2 = [ {\"action\": 0, \"x\": 800, \"y\": 1200, \"pointer\": 2, \"delay\": 1}, {\"action\": 2, \"x\": 800, \"y\": 1100, \"pointer\": 2, \"delay\": 20}, {\"action\": 2, \"x\": 800, \"y\": 1000, \"pointer\": 2, \"delay\": 20}, {\"action\": 1, \"x\": 800, \"y\": 1, \"pointer\": 2, \"delay\": 20} ]; var params = { \"type\": \"multiTouch\", \"arrays\": [touch1, touch2], \"timeout\": 1000 }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); "},"zh-cn/zk/global/zk-global-swipe.html":{"url":"zh-cn/zk/global/zk-global-swipe.html","title":"滑动动作接口","keywords":"","body":"滑动动作接口 文档函数中如果有selectors 选择器数组，更多选择器属性，请查看选择器与节点属性 swipe 滑动节点 滑动节点 @param selectors 选择器数组，更多选择器属性，请查看选择器与节点属性 @param endX 目标X坐标 @param endY 目标Y坐标 @param duration 动作持续时长，单位毫秒 @return 布尔型，true代表成功 false代表失败 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"swipe\", \"selectors\": [{ \"scrollable\": true }], \"endX\": 60, \"endY\": 200, \"duration\": 500 }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); swipeToPoint 滑动坐标到目标坐标 滑动坐标到目标坐标 @param startX 起始X坐标 @param startY 起始Y坐标 @param endX 目标X坐标 @param endY 目标Y坐标 @param duration 动作持续时长，单位毫秒 @return 布尔型，true代表成功 false代表失败 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"swipeToPoint\", \"selectors\": [{ \"scrollable\": true }], \"startX\": 1000, \"startY\": 1000, \"endX\": 60, \"endY\": 2000, \"duration\": 500 }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); isScrollEnd 是否滚动到底部了 是否滚动到底部了，如果查不到元素也会返回false @param selectors 选择器数组，更多选择器属性，请查看选择器与节点属性 @param direction 滚动方向 UP,DOWN,LEFT,RIGHT @return 布尔型，true代表成功 false代表失败 var request = require('request'); var url=\"http://127.0.0.1:20390/global\"; var p = { \"type\": \"isScrollEnd\", \"selectors\": [{ \"scrollable\": true }], \"direction\":\"UP\" }; var data = JSON.stringify(p); request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: data }, function(error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } } scrollForward 无指针向前滚动 执行条件：无障碍5.0以上或者手势执行为代理服务 向前滚动 @param selectors 选择器对象 @return {boolean|布尔型} var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"scrollForward\", \"selectors\": [{ \"clz\": \"android.support.v7.widget.RecyclerView\", \"scrollable\": true }], }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); scrollBackward 无指针向后滚动 执行条件：无障碍5.0以上或者手势执行为代理服务 向后滚动 @param selectors 选择器对象 @return {boolean|布尔型} var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"scrollBackward\", \"selectors\": [{ \"clz\": \"android.support.v7.widget.RecyclerView\", \"scrollable\": true }], }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); "},"zh-cn/zk/global/zk-global-drag.html":{"url":"zh-cn/zk/global/zk-global-drag.html","title":"拖动动作接口","keywords":"","body":"拖动动作接口 drag 从一个坐标到另一个坐标的拖动 从一个坐标到另一个坐标的拖动 @param startX 起始X坐标 @param startY 起始Y坐标 @param endX 目标X坐标 @param endY 目标Y坐标 @param duration 动作持续时长，单位毫秒 @return 布尔型，true代表成功 false代表失败 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"drag\", \"startX\": 1000, \"startY\": 1000, \"endX\": 100, \"endY\": 100, \"duration\": 1500 }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); dragTo 拖动节点到目标节点 拖动节点到目标节点 @param selectors 选择器数组，更多选择器属性，请查看选择器与节点属性 @param destObj 目标选择器数组，更多选择器属性，请查看选择器与节点属性 @param duration 动作持续时长，单位毫秒 @return 布尔型，true代表成功 false代表失败 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"dragTo\", \"selectors\": [{ \"text\": \"设置\" }], \"destObj\": [{ \"text\": \"浏览器\" }], \"duration\": 1500 }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); dragToPoint 拖动节点到目标坐标 拖动节点到目标坐标 @param selectors 选择器数组，更多选择器属性，请查看选择器与节点属性 @param endX 目标X坐标 @param endY 目标Y坐标 @param duration 动作持续时长，单位毫秒 @return 布尔型，true代表成功 false代表失败 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"dragToPoint\", \"selectors\": [{ \"clz\": \"android.support.v7.widget.RecyclerView\" }], \"endX\": 100, \"endY\": 100, \"duration\": 500 }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); "},"zh-cn/zk/global/zk-global-input.html":{"url":"zh-cn/zk/global/zk-global-input.html","title":"输入动作接口","keywords":"","body":"输入动作接口 currentIsOurIme 当前是否是我们的输入法 当前是否是我们的输入法 @return 布尔型，true代表成功 false代表失败 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"currentIsOurIme\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); inputText 通过选择器输入数据 通过选择器输入数据 @param selectors 选择器数组，更多选择器属性，请查看选择器与节点属性 @param content 数据字符串 @return 布尔型，true代表成功 false代表失败 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"inputText\", \"selectors\": [{ \"clz\": \"android.widget.EditText\" }], \"content\": \"是是是s\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); imeInputText 通过输入法输入内容 使用输入法输入内容，前提是已经设置本程序的输入法为默认输入法 适合没有节点的情况，例如游戏等 @param selectors 选择器数组，可以为空，如果为空，前提是输入框是聚焦的状态;更多选择器属性，请查看选择器与节点属性 @param content 数据字符串 @return 布尔型，true代表成功 false代表失败 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"imeInputText\", \"selectors\": [{ \"clz\": \"android.widget.EditText\" }], \"content\": \"是是是\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); pasteText 通过选择器粘贴数据 通过选择器粘贴数据 @param selectors 选择器数组，更多选择器属性，请查看选择器与节点属性 @param content 数据字符串 @return 布尔型，true代表成功 false代表失败 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"pasteText\", \"selectors\": [{ \"clz\": \"android.widget.EditText\" }], \"content\": \"是是是\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); clearTextField 通过选择器清除数据 通过选择器清除数据 @param selectors 选择器数组，更多选择器属性，请查看选择器与节点属性 @return 布尔型，true代表成功 false代表失败 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"clearTextField\", \"selectors\": [{ \"clz\": \"android.widget.EditText\" }] }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); "},"zh-cn/zk/global/zk-global-node.html":{"url":"zh-cn/zk/global/zk-global-node.html","title":"节点操作接口","keywords":"","body":"节点操作接口 参数中NID解释：节点的唯一标识，使用开发工具节点工具获取到，或者是NodeInfo对象中的nid 节点信息类has 通过选择器判断元素是否存在 通过选择器判断元素是否存在 @param selectors 选择器数组，更多选择器属性，请查看选择器与节点属性 @return 布尔型，true代表成功 false代表失败 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"has\", \"selectors\": [{ \"text\": \"设置\" }] }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); waitExistActivity 等待activity界面出现 等待activity界面出现 @param activity activity类名 @param timeout 超时时间 单位毫秒 @return 布尔型，true代表成功 false代表失败 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"waitExistActivity\", \"activity\": \"com.xx.MainActivity\", \"timeout\": 10000 }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); waitExistNode 通过选择器判断并等待元素是否存在 通过选择器判断并等待元素是否存在 @param selectors 选择器数组，更多选择器属性，请查看选择器与节点属性 @param timeout 超时时间 单位毫秒 @return 布尔型，true代表成功 false代表失败 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"waitExistNode\", \"selectors\": [{ \"text\": \"设置\" }], \"timeout\": 10000 }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); getNodeInfo 获取多个节点信息 获取多个节点信息 @param selectors 选择器数组，更多选择器属性，请查看选择器与节点属性 @param timeout 超时时间 单位毫秒 @return 节点信息集合JSON字符串节点信息属性 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"getNodeInfo\", \"selectors\": [{ \"text\": \"设置\" }], \"timeout\": 10000 }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); getOneNodeInfo 获取单个节点信息 获取单个节点信息 @param selectors 选择器数组，更多选择器属性，请查看选择器与节点属性 @param timeout 超时时间 单位毫秒 @return 单个节点信息JSON字符串节点信息属性 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"getOneNodeInfo\", \"selectors\": [{ \"text\": \"设置\" }], \"timeout\": 10000 }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); setFetchNodeMode 设置获取节点的模式 设置获取节点的模式 @param mode 1 是增强型， 2 是快速型，默认是增强型 @param fetchInvisibleNode 是否抓取隐藏的元素，默认不抓取 @param fetchNotImportantNode 是否抓取不重要的元素 @return 布尔型，true代表成功 false代表失败 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"setFetchNodeMode\", \"mode\": 1, \"fetchInvisibleNode\": true, \"fetchNotImportantNode\": true, }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); dumpXml 将元素节点变成XML 将元素节点变成XML @return 字符串 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"dumpXml\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); lockNode 锁定当前节点 锁定当前节点，锁定后，后面就算界面刷新，但是节点还是老的信息，需要和releaseNode进行配合才能进行解锁 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"lockNode\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); releaseNode 释放节点的锁 释放节点的锁，释放后，当界面刷新的时候，节点信息会变成最新的 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"lockNode\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); 单节点连续操作 以下操作均是建立在取得节点信息后，有节点的nid的时候才能进行，如何取得节点信息请看getOneNodeInfo或者getNodeInfo方法 getNodeInfoParent 该节点的父级节点 该节点的父级节点 @param nid nodeinfo的nid值节点信息类 @return 节点信息的JSON字符串 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"getNodeInfoParent\", \"nid\": \"ed21a0147283cd62b324d695a787e093\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); getNodeInfoChild 该节点的子节点 该节点的子节点 @param nid nodeinfo的nid值节点信息类 @param index 节点所有 从0开始 @return 节点信息的JSON字符串 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"getNodeInfoChild\", \"nid\": \"cc6a420515ac7940d60fd93155451fae\", \"index\": 0 }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); getNodeInfoAllChildren 该节点的所有子节点 该节点的所有子节点 @param nid nodeinfo的nid值节点信息类 @return 节点信息数组的JSON字符串 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"getNodeInfoAllChildren\", \"nid\": \"cc6a420515ac7940d60fd93155451fae\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); getPreviousSiblingNodeInfo 前面的兄弟节点 前面的兄弟节点 @param nid nodeinfo的nid值节点信息类 @return 节点信息数组的JSON字符串 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"getPreviousSiblingNodeInfo\", \"nid\": \"0019c4506d4cf5bb325d3bc932267e32\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); getNextSiblingNodeInfo 后面的兄弟节点 后面的兄弟节点 @param nid nodeinfo的nid值节点信息类 @return 节点信息数组的JSON字符串 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"getNextSiblingNodeInfo\", \"nid\": \"0019c4506d4cf5bb325d3bc932267e32\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); getSiblingNodeInfo 所有兄弟节点 所有兄弟节点 @param nid nodeinfo的nid值节点信息类 @return 节点信息数组的JSON字符串 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"getSiblingNodeInfo\", \"nid\": \"0019c4506d4cf5bb325d3bc932267e32\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); inputTextNodeInfo 节点输入 节点输入 @param nid nodeinfo的nid值节点信息类 @param content 要输入的内容 @return 布尔型 true 代表保存，false代表不保存 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"inputTextNodeInfo\", \"nid\": \"64bbd7471d558ba06f594686e1d90ea1\", \"content\": \"我是内容\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); pasteTextNodeInfo 节点粘贴输入 节点粘贴输入 @param nid nodeinfo的nid值节点信息类 @param content 要输入的内容 @return 布尔型 true 代表成功，false代表失败 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"pasteTextNodeInfo\", \"nid\": \"64bbd7471d558ba06f594686e1d90ea1\", \"content\": \"我是内容\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); imeInputTextNodeInfo 节点输入法输入 节点输入法输入 @param nid ,可以为空，但是控件提前是聚焦状态 nodeinfo的nid值节点信息类 @param content 要输入的内容 @return 布尔型 true 代表成功，false代表失败 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"imeInputTextNodeInfo\", \"nid\": \"64bbd7471d558ba06f594686e1d90ea1\", \"content\": \"我是内容\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); clearTextNodeInfo 清除节点数据 清除节点数据 @param nid nodeinfo的nid值节点信息类 @return 布尔型 true 代表成功，false代表失败 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"clearTextNodeInfo\", \"nid\": \"64bbd7471d558ba06f594686e1d90ea1\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); refreshNodeInfo 刷新节点数据 刷新节点数据 @param nid nodeinfo的nid值节点信息类 @return 布尔型 true 代表成功，false代表失败 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"refreshNodeInfo\", \"nid\": \"64bbd7471d558ba06f594686e1d90ea1\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); isValidNodeInfo 节点是否有效 节点是否有效 @param nid nodeinfo的nid值节点信息类 @return 布尔型 true 代表成功，false代表失败 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"isValidNodeInfo\", \"nid\": \"64bbd7471d558ba06f594686e1d90ea1\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); clickNodeInfo 1、先通过getOneNodeInfo获取到NodeInfo对象 2、通过NodeInfo对象中的bounds属性，自行计算出要点击的x，y坐标，然后调用clickPoint方法 longClickNodeInfo 1、先通过getOneNodeInfo获取到NodeInfo对象 2、通过NodeInfo对象中的bounds属性，自行计算出要点击的x，y坐标，然后调用 longClickPoint 方法 clickNodeInfoEx 无指针方式点击 执行条件：无障碍5.0以上或者手势执行为代理服务 无指针方式点击选择器，节点必须是可点击的才行 @param nid nodeinfo的nid值节点信息类 布尔型 true 代表成功，false代表失败 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"clickNodeInfoEx\", \"nid\": \"0019c4506d4cf5bb325d3bc932267e32\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); longClickNodeInfoEx 无指针方式长点击 执行条件：无障碍5.0以上或者手势执行为代理服务 无指针方式长点击选择器，节点必须是可点击的才行 @param nid nodeinfo的nid值节点信息类 布尔型 true 代表成功，false代表失败 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"longClickNodeInfoEx\", \"nid\": \"0019c4506d4cf5bb325d3bc932267e32\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); scrollForwardNodeInfo 向前滚动 执行条件：无障碍5.0以上或者手势执行为代理服务 向前滚动 @param nid nodeinfo的nid值节点信息类 @return {boolean|布尔型} var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"scrollForwardNodeInfo\", \"nid\": \"d781a853cf8a116cc31c7bab9ef4c405\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); scrollBackwardNodeInfo 向后滚动 执行条件：无障碍5.0以上或者手势执行为代理服务 向后滚动 @param nid nodeinfo的nid值节点信息类 @return {boolean|布尔型} var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"scrollBackwardNodeInfo\", \"nid\": \"d781a853cf8a116cc31c7bab9ef4c405\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); getOneNodeInfoForNode 取得子节点下面的某个节点 取得子节点下面的某个节点 @param nid nodeinfo的nid值节点信息类 @param selectors 选择器数组，更多选择器属性，请查看选择器与节点属性 @param timeout 超时时间 单位毫秒 @return 单个节点信息JSON字符串节点信息属性 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"getOneNodeInfoForNode\", \"nid\": \"d781a853cf8a116cc31c7bab9ef4c405\", \"selectors\": [{ \"clz\": \"android.widget.TextView\" }], \"timeout\": 10 * 1000 }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); getNodeInfoForNode 取得子节点下面的所有节点 取得子节点下面的所有节点 @param nid nodeinfo的nid值节点信息类 @param selectors 选择器数组，更多选择器属性，请查看选择器与节点属性 @param timeout 超时时间 单位毫秒 @return 节点信息集合JSON字符串节点信息属性 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"getNodeInfoForNode\", \"nid\": \"d781a853cf8a116cc31c7bab9ef4c405\", \"selectors\": [{ \"clz\": \"android.widget.TextView\" }], \"timeout\": 10 * 1000 }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); "},"zh-cn/zk/global/zk-global-systemkey.html":{"url":"zh-cn/zk/global/zk-global-systemkey.html","title":"系统按键接口","keywords":"","body":"系统按键接口 power 执行条件：无障碍5.0以上或者手势执行为代理服务 模拟电源按键，无障碍是电源对话框，代理模式是电源键按下 @return {null|布尔型} var request = require('request'); var url=\"http://127.0.0.1:20390/global\"; var data = { \"type\":\"power\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: data }, function(error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } } home 返回桌面 返回桌面 @return 布尔型 var request = require('request'); var url=\"http://127.0.0.1:20390/global\"; var data = { \"type\":\"home\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: data }, function(error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } } back 返回 返回 @return 布尔型 var request = require('request'); var url=\"http://127.0.0.1:20390/global\"; var data = { \"type\":\"back\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: data }, function(error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } } openNotification 打开通知栏 打开通知栏 @return 布尔型 var request = require('request'); var url=\"http://127.0.0.1:20390/global\"; var data = { \"type\":\"openNotification\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: data }, function(error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } } openQuickSettings 打开快速设置 打开快速设置 @return 布尔型 var request = require('request'); var url=\"http://127.0.0.1:20390/global\"; var data = { \"type\":\"openQuickSettings\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: data }, function(error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } } recentApps 最近APP任务按键 最近APP任务按键 @return 布尔型 var request = require('request'); var url=\"http://127.0.0.1:20390/global\"; var data = { \"type\":\"recentApps\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: data }, function(error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } } getRunningPkg 取得当前运行的App包名 取得当前运行的App包名 @return 字符串 var request = require('request'); var url=\"http://127.0.0.1:20390/global\"; var data = { \"type\":\"getRunningPkg\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: data }, function(error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } } getRunningActivity 取得当前运行的Activity类名 取得当前运行的Activity类名 @return 字符串 var request = require('request'); var url=\"http://127.0.0.1:20390/global\"; var data = { \"type\":\"getRunningActivity\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: data }, function(error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } } "},"zh-cn/zk/global/zk-global-notice.html":{"url":"zh-cn/zk/global/zk-global-notice.html","title":"通知栏接口","keywords":"","body":"通知栏接口 hasNotificationPermission 检查是否含有状态栏监听权限 检查是否含有状态栏监听权限 @return 布尔型 var request = require('request'); var url=\"http://127.0.0.1:20390/global\"; var data = { \"type\":\"hasNotificationPermission\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: data }, function(error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } } requestNotificationPermission 请求监听状态栏的权限 请求监听状态栏的权限 @param timeout 超时时间，单位毫秒 @return 布尔型 var request = require('request'); var url=\"http://127.0.0.1:20390/global\"; var data = { \"type\":\"requestNotificationPermission\", \"timeout\":10000, }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: data }, function(error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } } getLastNotification 获取最近通知栏对象 获取最近通知栏对象 @param pkg 指定包名 @param size 指定获取的条数 @return JSON数组字符串，请参考获取通知 var request = require('request'); var url=\"http://127.0.0.1:20390/global\"; var data = { \"type\":\"getLastNotification\", \"pkg\":\"\", \"size\":10 }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: data }, function(error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } } shotNotification 将通知发射处理，相当于点击了通知栏 将通知发射处理，相当于点击了通知栏 @param seqId getLastNotification方法获取通知栏数据的seqId @return 布尔型 var request = require('request'); var url=\"http://127.0.0.1:20390/global\"; var data = { \"type\":\"shotNotification\", \"seqId\":\"XXXXXX\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: data }, function(error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } } cancelNotification 将通知进行取消操作 将通知进行取消操作 @param seqId getLastNotification方法获取通知栏数据的seqId @return 布尔型 var request = require('request'); var url=\"http://127.0.0.1:20390/global\"; var data = { \"type\":\"cancelNotification\", \"seqId\":\"XXXXXX\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: data }, function(error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } } ignoreNotification 忽略通知 忽略通知，从缓存队列移除，下次将不会获取 @param seqId getLastNotification方法获取通知栏数据的seqId @return 布尔型 var request = require('request'); var url=\"http://127.0.0.1:20390/global\"; var data = { \"type\":\"ignoreNotification\", \"seqId\":\"XXXXXX\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: data }, function(error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } } getLastToast 获取toast数据 获取toast数据 @param pkg 指定包名 @param size 指定获取的条数 @return JSON数组字符串，请参考获取Toast var request = require('request'); var url=\"http://127.0.0.1:20390/global\"; var data = { \"type\":\"getLastToast\", \"pkg\":\"\", \"size\":10 }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: data }, function(error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } } "},"zh-cn/zk/global/zk-global-floatview.html":{"url":"zh-cn/zk/global/zk-global-floatview.html","title":"悬浮窗接口","keywords":"","body":"悬浮窗接口 hasFloatViewPermission 检查是否含有浮窗权限 检查是否含有浮窗权限 @return 布尔型 var request = require('request'); var url=\"http://127.0.0.1:20390/global\"; var data = { \"type\":\"hasFloatViewPermission\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: data }, function(error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } } requestFloatViewPermission 请求展示浮窗的权限 请求展示浮窗的权限 @param timeout 超时时间，单位毫秒 @return 布尔型 var request = require('request'); var url=\"http://127.0.0.1:20390/global\"; var data = { \"type\":\"requestFloatViewPermission\", \"timeout\":10000 }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: data }, function(error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } } showLogWindow 展示日志浮窗 展示日志浮窗 @return 布尔型 var request = require('request'); var url=\"http://127.0.0.1:20390/global\"; var data = { \"type\":\"showLogWindow\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: data }, function(error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } } closeLogWindow 关闭日志浮窗 关闭日志浮窗 @return 布尔型 true 代表保存，false代表不保存 var request = require('request'); var url=\"http://127.0.0.1:20390/global\"; var p = { \"type\":\"closeLogWindow\" }; var data = JSON.stringify(p); request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: data }, function(error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } } setLogViewSizeEx 设置日志窗口大小 设置日志窗口大小扩展函数 @param map 例如 { \"x\":100, \"y\":100, \"w\":100, \"h\":200, \"textSize\":12, \"backgroundColor\":\"#ffffff\", \"title\":\"我是日志\", \"showTitle\":true } 解释： x: 起始X位置 y: 起始Y位置 w:宽度 h* :高度 textSize:日志的字体大小 backgroundColor:背景颜色，例如#336699 title:日志框标题 showTitle：是否显示标题 @return bool true代表成功，false代表失败 var request = require('request'); var url = \"http://127.0.0.1:20390/global\"; var params = { \"type\": \"setLogViewSizeEx\", \"x\": 100, \"y\": 200, \"w\": 600, \"h\": 600, \"textSize\": 12, \"backgroundColor\": \"#ffffff\", \"title\": \"我是日222志\", \"showTitle\": false }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); setLogText 展示消息到悬浮窗日志 展示消息到悬浮窗日志中 @param msg 消息 @return 布尔型 var request = require('request'); var url=\"http://127.0.0.1:20390/global\"; var data = { \"type\":\"setLogText\", \"msg\": \"msg\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: data }, function(error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } } setAllLogEnd 结束所有日志展示 结束所有日志展示，恢复悬浮窗可拖动 @return 布尔型 var request = require('request'); var url=\"http://127.0.0.1:20390/global\"; var data = { \"type\":\"setAllLogEnd\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: data }, function(error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } } "},"zh-cn/zk/zk-agent.html":{"url":"zh-cn/zk/zk-agent.html","title":"代理事件模块接口","keywords":"","body":" 对应功能函数中的 代理事件 模块 setCurrentIme 设置我们的输入法 设置当前的输入法，用于输入数据 @return {boolean|布尔型} var request = require('request'); var url = \"http://127.0.0.1:20390/agentEvent\"; var params = { \"type\": \"setCurrentIme\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); restoreIme 恢复输入法 恢复到之前的输入法 @return {boolean|布尔型} var request = require('request'); var url = \"http://127.0.0.1:20390/agentEvent\"; var params = { \"type\": \"restoreIme\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); inputEvent 执行输入事件 执行输入事件 @param action 动作，请看类: MotionEvent.ACTION_* @param x x坐标 @param y y坐标 @param metaState 控制按键，比如说shift键，alt键，ctrl键等控制键, 0或者 1 any meta info @return 布尔型 true 代表成功 false代表失败 var request = require('request'); var url = \"http://127.0.0.1:20390/agentEvent\"; var params = { \"type\": \"inputEvent\", \"action\": 0, \"x\": 1, \"y\": 1, \"metaState\": 0, }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); touchDown 按下事件 执行按下输入事件 @param x x坐标 @param y y坐标 @return 布尔型 true 代表成功 false代表失败 var request = require('request'); var url = \"http://127.0.0.1:20390/agentEvent\"; var params = { \"type\": \"touchDown\", \"x\": 1, \"y\": 1 }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); touchMove 移动事件 执行移动输入事件 @param x x坐标 @param y y坐标 @return 布尔型 true 代表成功 false代表失败 var request = require('request'); var url = \"http://127.0.0.1:20390/agentEvent\"; var params = { \"type\": \"touchMove\", \"x\": 1, \"y\": 1 }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); touchUp 弹起输事件 执行弹起输入事件 @param x x坐标 @param y y坐标 @return 布尔型 true 代表成功 false代表失败 var request = require('request'); var url = \"http://127.0.0.1:20390/agentEvent\"; var params = { \"type\": \"touchUp\", \"x\": 1, \"y\": 1 }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); pressKey 模拟按键 模拟按键,例如home back等 @param key 对应的值分别为 home, back, left, right, up, down, center, menu, search, enter, delete(or del), recent(recent apps), volume_up, volume_down, volume_mute, camera, power *@return 布尔型 true 成功, false 失败 var request = require('request'); var url = \"http://127.0.0.1:20390/agentEvent\"; var params = { \"type\": \"pressKey\", \"key\": \"back\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); pressKeyCode 模拟键盘输入 模拟键盘输入 @param keyCode 键盘的key，参见KeyEvent.KEYCODE_* @return 布尔型 true 代表成功，false 代表失败 var request = require('request'); var url = \"http://127.0.0.1:20390/agentEvent\"; var params = { \"type\": \"pressKeyCode\", \"keyCode\": 4 }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); pressKeyCodeWithMetaState 模拟键盘输入 模拟键盘输入 @param keyCode keyCode 键盘的key，参见KeyEvent.KEYCODE_* @param metaState metaState 控制按键，比如说shift键，alt键，ctrl键等控制键, 0或者 1 @return 布尔型 true 代表成功，false 代表失败。 var request = require('request'); var url = \"http://127.0.0.1:20390/agentEvent\"; var params = { \"type\": \"pressKeyCodeWithMetaState\", \"keyCode\": 4, \"metaState\":1 }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); menu 打开菜单 打开菜单 @return {null|布尔型} var request = require('request'); var url = \"http://127.0.0.1:20390/agentEvent\"; var params = { \"type\": \"menu\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); enter Enter键 Enter键 @return {null|布尔型} var request = require('request'); var url = \"http://127.0.0.1:20390/agentEvent\"; var params = { \"type\": \"enter\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); delete 删除键 删除键 @return {null|布尔型} var request = require('request'); var url = \"http://127.0.0.1:20390/agentEvent\"; var params = { \"type\": \"delete\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); closeScreen 关闭屏幕，省点模式 关闭屏幕，屏幕不亮，但是依然可以自动点击 @return 布尔型 true 成功，false 失败 var request = require('request'); var url = \"http://127.0.0.1:20390/agentEvent\"; var params = { \"type\": \"closeScreen\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); lightScreen 点亮屏幕 点亮屏幕，和closeScreen相反的动作 @return 布尔型 true 成功，false 失败 var request = require('request'); var url = \"http://127.0.0.1:20390/agentEvent\"; var params = { \"type\": \"lightScreen\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); "},"zh-cn/zk/zk-image.html":{"url":"zh-cn/zk/zk-image.html","title":"图色模块接口 - 开发中","keywords":"","body":""},"zh-cn/zk/zk-shell.html":{"url":"zh-cn/zk/zk-shell.html","title":"Shell命令模块接口","keywords":"","body":" 对应功能函数中的 shell事件 模块 installApp 安装 apk 安装 apk @param path 应用程序的包名 @return true 代表成功，false 代表失败 var request = require('request'); var url = \"http://127.0.0.1:20390/shell\"; var params = { \"type\": \"installApp\", \"path\": \"/sdcard/aaa.apk\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); uninstallApp 卸载应用程序 卸载应用程序 @param packageName 应用程序的包名 @return true 代表成功，false 代表失败 var request = require('request'); var url = \"http://127.0.0.1:20390/shell\"; var params = { \"type\": \"uninstallApp\", \"packageName\": \"com.aaaa\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); stopApp 停止正在执行的应用 停止正在执行的应用 @param packageName 应用程序的包名 @return true 代表成功，false 代表失败 var request = require('request'); var url = \"http://127.0.0.1:20390/shell\"; var params = { \"type\": \"stopApp\", \"packageName\": \"com.aaaa\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); execCommand 执行Shell命令 执行Shell命令 @param command 命令，例如安装App ： pm install /sdcard/app.apk @return 命令执行后返回的字符串结果 var request = require('request'); var url = \"http://127.0.0.1:20390/shell\"; var params = { \"type\": \"execCommand\", \"command\": \"ls -al /sdcard/\" }; request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: params }, function (error, response, body) { if (!error && response.statusCode == 200) { console.log(body) } else { console.log(error) } }); "},"zh-cn/funcs/plugin/plugins.html":{"url":"zh-cn/funcs/plugin/plugins.html","title":"插件开发","keywords":"","body":"说明 插件本身是一个apk包，和普通的android开发无任何区别 开发的时候可以使用Android Studio进行开发，打包成apk即可 本章节主要介绍使用EasyClick开发开发插件 新建插件工程 使用IDEA创建项目选择'EasyClick 插件工程' 点击下一步并完成，会自动生成对应的java类和配置信息 插件目录结构 src/js/main.js 这个文件是js调用插件相关方法的测试入口 src/com/ 这个文件夹下面存放的的java源码，PluginClz 类是默认生成的插件入口类 libs/jarlibs文件夹用于存放三方引用jar包，会被合并到插件中 libs/solibs 存放so封装的文件，会被编译到插件的 lib 文件夹中 libs/resources 存放资源的文件，会被编译到插件的 resources 文件夹中 libs/jslibs 存放JS类库文件，不会编译到插件中，仅用来进行测试和调用 作为插件开发者，只要关注java代码的编写即可，如果你有jni的调用，请将so文件放到libs/solibs中 插件java类 PluginClz PluginClz是默认生成的插件java类 test 方法是默认生成的插件方法 实际调用请看main.js中的调用 插件运行 执行菜单栏 'EasyClick 开发工具 - 运行工程' 即可，前提是要连接到手机 插件打包 执行菜单栏 'EasyClick 开发工具 - 打包工程' 即可，打包结果请看EasyClick 运行日志的输出 插件使用 将打好包的apk文件，放到脚本工程的plugin 文件夹下 使用 loadDex 函数载入插件 使用new方法生成插件对象实例即可调用 "},"zh-cn/funcs/plugin/javajs.html":{"url":"zh-cn/funcs/plugin/javajs.html","title":"Java-JS混合开发","keywords":"","body":"说明 混合开发是把java和js放在一起编写，js调用java的方法 编译后java代码和jar包会变成一个defaultplugin.apk文件作为插件使用 本章节主要介绍使用EasyClick 混合开发 新建Java-JS混合项目 使用IDEA创建项目选择'EasyClick Java-JS混合项目' 点击下一步并完成，会自动生成对应的java类和配置信息 目录结构 src/js/main.js 这个文件是js调用插件相关方法的测试入口 src/com/ 这个文件夹下面存放的的java源码，PluginClz 类是默认生成的插件入口类 libs/jarlibs文件夹用于存放三方引用jar包，会被合并到插件中 libs/solibs 存放so封装的文件，会被编译到插件的 lib 文件夹中 libs/resources 存放资源的文件，会被编译到插件的 resources 文件夹中 libs/jslibs 存放JS类库文件，不会编译到插件中，仅用来进行测试和调用 如果你有jni的调用，请将so文件放到libs/solibs中 默认java类 PluginClz PluginClz是默认生成的java类 test 方法是默认生成的默认方法 实际调用请看main.js中的调用 main.js 使用Java java编译后是插件形式，插件名称是defaultplugin.apk，请在脚本运行的时候调用 loadDex(\"defaultplugin.apk\"); loadDex 函数载入插件 然后在使用importClass或者importPackage方法进行引入java类 使用new方法生成插件对象实例即可调用 运行 执行菜单栏 'EasyClick 开发工具 - 运行工程' 即可，前提是要连接到手机 打包 执行菜单栏 'EasyClick 开发工具 - 打包工程' 即可，打包结果请看EasyClick 运行日志的输出 "},"zh-cn/active-device.html":{"url":"zh-cn/active-device.html","title":"激活设备","keywords":"","body":" 本章节讲述如何激活设备 IDEA开发工具激活 进入IDEA，选择EasyClick开发工具 - 激活设备 - 激活模式1或者激活模式2 点击即可 打开EasyClick运行日志，如果提示激活成功就可以了 电脑批量激活 到下载EasyClick开发插件的网盘，下载批量激活工具，解压后，直接运行对应的exe程序即可 脱离电脑激活 名词解释：激活APP安装上的手机简称为A， 被激活的手机简称为B 到下载EasyClick开发插件的网盘，下载激活的App 使用一根OTG数据线，下载激活App并安装到手机A上 将OTG数据线公头连接到手机A，母头连接手机B，打开激活App会自动扫描并激活 如果手机B弹出USB授权，请同意即可 操作教程 打开OTG 认识OTG数据线 链接设备 如有USB调试框弹出，请运行 激活传输文件 激活成功 如果中间连接不上设备，可以拔插数据线多试一次 "},"zh-cn/question-answer.html":{"url":"zh-cn/question-answer.html","title":"常见问题","keywords":"","body":"为什么选择JavaScript语言? 简单易上手，资料多 会基本语法和函数调用就可以编程 开发工具成熟易上手 JS教程：https://www.runoob.com/js/js-tutorial.html 5.0与老版本的不同（必读） 更改 取消了tab.ini多标签布局，使用ui.js中的ui.layout进行替代， 参考 多标签支持 新增概念 节点获取服务：这个服务用于获取节点信息，如果需要，则需要打开手机上的无障碍服务 底层代理服务：用于在处理底层动作的事务，可以替代无障碍执行手势动作等 手势执行服务：用于执行手势动作，可以选择无障碍和代理模式，无障碍的部分动作需要7.0以上手机版本支持，代理模式无任何限制，请根据实际情况选择 特性 脚本和UI可以进行任意交互 所有的服务都变成可选，对应用测试或者游戏测试用户比较友好 重写了找色函数，支持多方向查找 游戏测试用户可以不必要开启无障碍，只用代理服务也能完成自动化测试 UI参数未更新或者混乱 该问题是因为经常换tag导致，可以在手机上清空EC调试程序缓存，正式打包后不会出现该问题 IDEA 新建工程问题 将模块添加到项目中时出错 错误信息：Argument for @NotNull parameter 'file' of com/intellij/openapi/roots/impl/ContentEntryImpl.addSourceFolder must not be nul 解决：关闭idea和adb.exe进程之后，再重新打开就ok了 或者idea换2019.3的版本 或者使用管理员方式运行IDEA，有可能是存在权限问题 函数不生效 使用代理模块的函数不生效，请检查运行模式是否是代理模式 开发工具连接不到手机? 这种情况是因为adb连接不成功导致的，adb连接需要满足一下几个条件： 手机开启usb调试模式 手机通过数据线连接上电脑 没有其他占用adb工具的程序 链接设备问题 比如电脑休眠以后连不上，重启就好，模拟器或者个别机型连不上，先下载ec.apk安装以后再链接,就好了 还有就是IDE开时间长了或者开好几个模拟器，连不上，重启开发工具试试 手机连接后，拔掉重新插入不识别手机？ 1、尝试使用进程管理器杀死adb进程，再次连接 2、使用360等手机助手连接一次，如果助手连接上，在使用开发工具连接；如果助手连接不上，可能是驱动问题 WIFI直连设备 1、请在手机上按照EC调试程序，如果没有安装，直接进入第2步，会弹出二维码扫描安装EC调试程序 2、EasyClick 开发工具 - 设备连接 - WIFI直连，输入手机的IP地址即可，在EasyClick日志控制台可以看到详细日志 抓取节点 1、链接上模拟器后一直提示节点服务提示没开启 节点服务与运行模式有关系，开发阶段请先激活设备，EC调试程序会自动启动节点服务 ，另外可以手动开启无障碍服务，并且在EC调试程序中使用无障碍的运行模式 代理模式下，由于启动代理服务需要点时间，一般在10 s内，请注意观察EasyClick控制台日志启动 \"正在初始化环境\" 字样 2、截图问题 EC开发工具会有多种截图模式，WIFI直连的情况下，抓取节点会要求获取截屏权限，请注意手机设备的提示并授权 Adb被占用解决办法 手机开启usb调试模式 关闭其他占用adb的软件 用任务管理器结束掉所有的ADB，确保手机没有占用adb的命令 电脑上的各种杀毒管家，刷机助手等也会占用adb，确保已经关闭 部分手机使用utils模块打开APP失效 例如小米手机权限问题导致无法使用openAppByName等打开APP函数，请到权限管理允许启动三方应用权限，或者允许全部的权限 OPPO 解决方法： https://www.jianshu.com/p/5f6d8379533b 安卓10无法后台预览或者打开应用，可以给EC调试版本赋予悬浮窗权限，或者在脚本中调用requestFloatViewPermission(10);方法请求并赋予权限 屏幕映射不成功 由于机型兼容性问题，可能导致屏幕映射不成功，不影响节点获取，两个功能是独立的。 可以用三方的，比如 qtscrcpy，或者scrcpy 如何开启 WIFI ADB 请参考教程：https://www.jianshu.com/p/a9543f2e89de 整理一下命令，方便使用 usb 连接手机 adb tcpip 5555 adb shell ifconfig wlan0 adb connect 手机ip地址 打开三方APP函数不生效 小米系统请允许 \"后台弹出界面\"，其他的如果有限制也可以自行百度解决 具体参考：https://blog.csdn.net/shenshibaoma/article/details/103909618 或者http://www.360doc.com/content/19/0814/09/26794451_854750882.shtml 小米之类的手机点击没反应 因为开发者选项中的【USB 调试（安全设置）】没有开启，开启即可 开启地址参考：https://blog.csdn.net/jackeny37/article/details/74516350 打包后运行不能点击 如果EC调试版本和打包的APP同时存在，两个APP运行模式不同，可能有冲突，卸载EC调试版本即可 3.x 与 4.x 迁移 3.X版本自动化服务是脚本运行的必要条件，4.x 将自动化服务作为非必要条件，在4.x中使用自动化服务请自行在脚本中判断或者启动服务环境， 启动环境和判断环境 使用图色函数截不到图或者找色找图不生效 基于安卓原生的机制，在申请屏幕截图权限，如果屏幕没有任何刷新，图像队列就没有图，会导致该情况发生 建议解决办法，在申请屏幕截图权限后，对屏幕进行刷新，例如点击、滑动等操作，即可刷新图像队列并取到图片 在代码中写for循环，多试试截图 截图有色差 由于系统的api可能会有色差，如果是代理模式，可以使用captureFullScreenEx截屏以消除色差 IDEA截不到图 请在截图的时候，如果手机上有授权框弹出，请进行授权并勾选不再提示，保证后续每次都是自动授权的 远程调试 请参考 远程调试 JSON.stringify 内存溢出 如果有以下错误，请检查一下要转换的对象中是否有java的string，解决方法将原来的string转为js的字符串 例如 s= s +\"\" 这样既可 STACK_TRACE=java.lang.StackOverflowError: stack size 1039KB at java.lang.reflect.Method.invoke(Native Method) at org.mozilla.javascript.MemberBox.invoke(Unknown Source:4) at org.mozilla.javascript.JavaMembers.get(Unknown Source:58) at org.mozilla.javascript.NativeJavaObject.get(Unknown Source:16) at org.mozilla.javascript.ScriptableObject.getProperty(Unknown Source:1) at org.mozilla.javascript.NativeJSON.str(Unknown Source:7) at org.mozilla.javascript.NativeJSON.jo(Unknown Source:63) at org.mozilla.javascript.NativeJSON.str(Unknown Source:237) at org.mozilla.javascript.NativeJSON.jo(Unknown Source:63) "},"zh-cn/agreement.html":{"url":"zh-cn/agreement.html","title":"用户协议","keywords":"","body":"用户协议 特别提示 《EasyClick(易点软件)用户协议》（以下简称“本协议”）适用于所有使用易点软件服务的用户（包括EC调试版、EC个人版、EC企业版等，以下或称“您”）。本协议一经同意并接受 即形成您与易点软件所属的公司及其关联公司（以下简称“易点软件”）间有法律约束力之文件。您确认，您已详细阅读了本协议所有内容，您充分理解并同意接受本协议的全部内容。 我们还需要提醒您的是，如本协议内容发生修改或更新，我们将会在易点软件提示修改内容并公布。您在使用易点软件公司提供的各项服务之前，应仔细阅读本协议，如您不同意变更后的协议内容，应立即停用易点软件及相关服务。 一、易点软件使用规则 易点软件是一个可以自动模拟执行您在手机、平板屏幕操作的一切动作的平台软件，可以录制您的屏幕操作然后播放，也可以运行第三方作者用 Javascript 脚本语言编写的脚本（易点软件不编写任何脚本）。 易点软件是您测试软件 BUG 稳定性、娱乐游戏时的好帮手，但易点软件本身并不对任何游戏或软件进行修改、加速。 易点软件在正确安装后，您有权免费试用易点软件，但易点软件有权终止免费服务。如果您想要取消上述限制，则须通过合法渠道购买授权码。您确认您明确知晓，您向易点软件购买的仅仅是易点软件软件本身的使用许可， 并不包含任何脚本。同时，易点软件有权对上述试用政策作出调整，但无论如何，在您根据易点软件的销售政策购买易点软件之前，易点软件有权随时停止您使用易点软件的权限。 您知晓并确认，就易点软件安卓版本，由于安卓设备种类繁多，如果因为安卓设备厂商对于安卓系统的修改等原因，导致易点软件无法正常使用的，虽然易点软件会尽一切技术上的努力保持易点软件的正常使用，但易点软件对此不承担任何责任，且不会向您退款。您确认您在购买易点软件之前知晓该风险的存在并愿意承担该风险。 您知晓并确认，易点软件在正确安装后，里面并不自带任何脚本，易点软件不编写任何脚本。您有权自行录制、编写任何脚本，您也可以通过购买或者其他合法渠道获得脚本，但您不得通过任何渠道获得任何违反中华人民共和国法律法规或侵犯第三方合法权益的脚本。易点软件的官网、论坛以及其他产品中可能存在脚本，但您确认您知晓，这些脚本并非易点软件编写或提供，而是由其他用户上传，即便您是从上述渠道获得的脚本，易点软件也不保证上述脚本的正确性、安全性、合法性，易点软件不对任何脚本引发的任何问题向您承担任何责任，您使用任何脚本引发的任何后果由您自行承担。 您知晓并确认，您自行获得相关脚本后，如果在使用、运行相关脚本的过程中造成了各种可能的不利影响，比如封号，丢失账号数据，或运行脚本导致违反目标程序的用户协议等,您须自行承担各种不利影响，您无权要求易点软件承担任何责任。 您知晓并确认，您在购买易点软件授权码时，可以在易点软件官方(http://ieasyclick.com)购买,或者易点软件指定的其他官方渠道购买。您必须采用易点软件指定的方式购买授权，可供购买方式包括但不限于：网上银行、第三方支付（例如支付宝、财付通等）、手机充值卡。您的购买行为表示您已经同意并自愿遵守易点软件的相关授权规则（授权规则的修改权及最终解释权均归易点软件，具体内容以易点软件官方公布的授权规则为准）。 您知晓并确认，您仅可以通过上述官方渠道购买授权码，不得购买来源不明的授权码。易点软件有权对通过非正常途径充值的授权码进行冻结。易点软件保留向通过冒充、盗用他人身份或者帐号等非正常途径购买授权码的单位或个人追究法律责任的一切权力。 您知晓并确认，易点软件授权码一旦购买成功并激活使用，购买即确定完成，您不得要求退还已付金额。 您知晓并确认，易点软件企业版的中控器属于本协议所称的“易点软件”软件的一部分。如您需要购买使用易点软件企业版的，您应当事先通过易点软件网站了解企业版的功能特点以及与普通版的区别。您购买企业版后，无权再因企业版的功能无法满足您的要求等原因要求易点软件退款或转换为普通版。 您知晓并确认，易点软件公司终止运营或者运营权发生转移的，有权提前30日予以公告。 您知晓并确认，易点软件提醒您妥善保管好您的授权码。非因易点软件原因造成的授权码遗失或泄露造成授权码无法使用的，易点软件不承担任何责任。 您知晓并确认，使用易点软件进行自动化测试编写时，必须要遵守法律法规原则，不得利用软件开发灰产、黑产等系列的自动化以此牟利 您知晓并确认，使用易点软件进行自动化测试编写时，用户必须遵守国家或地区的相关法律法规 二、帐号管理 易点软件服务可能需要您注册帐号，如需要您注册的，您应保证其注册信息真实、准确、完整、合法。如上述信息发生任何变化，您应及时变更注册信息。若您提供给易点软件的注册信息不真实、不准确、不完整、不合法，含有违法或不良信息的，易点软件有权不予注册，并保留终止您使用易点软件各项服务的权利。您对于注册信息的不真实、不完整、不准确、未及时更新的，易点软件有权采取通知限期改正、暂停使用、注销登记等措施，因此所导致的一切不利后果及损失，应由您承担一切责任。 您有义务妥善保管其在易点软件申请的账号及密码，不得泄漏给任何第三人。您必须为其账号及密码之全部行为负责，此账号及密码项下全部行为即视为您本身之行为。 您账号及密码仅限于您个人使用，非经易点软件同意，您不得出借、移转或让与等任何方式给其他第三人使用，否则易点软件有权解除本协议并不退还您费用。易点软件不能也不会对因您未能遵守本款约定而发生的任何损失、损毁及其他不利后果负责。您理解易点软件对您的请求采取行动需要合理期限，在此之前，易点软件对已执行的指令及（或）所导致的您的损失不承担任何责任。 易点软件承诺对获得的您的个人信息主要为其正常的记录和管理客户信息及为本协议之目的使用。尽管易点软件对您的个人信息保护做了极大的努力，但是仍然不能保证现有的安全技术措施使您的隐私信息等不受任何形式的损失，您理解并同意，易点软件不对非因易点软件主观故意而导致的任何损害赔偿承担责任，包括但不限于商誉、隐私、使用、数据等方面的损失或其他无形损失的损害赔偿（无论易点软件是否已被告该等损害赔偿的可能性）。 三、知识产权 ·易点软件网站(http://ieasyclick.com) 所有的LOGO、商标、图形、易点软件软件及其他产品、技术、源代码与所有程序的知识产权及其他合法权益均属于易点软件，在此并未授权。 未经易点软件许可，任何人不得擅自以任何方式（包括但不限于：以非法的方式复制、传播、展示、镜像、上传、下载）使用，或通过非常规方式（如：恶意干预数据）影响易点软件的正常服务,也不得对易点软件软件进行任何修改、反向编译，更不得在易点软件软件中放置或嵌入木马程序或后门等危害第三方数据安全性的程序。否则，易点软件将依法追究法律责任。 易点软件特别提醒您：易点软件不编写任何脚本。您有权自行录制、编写任何脚本，您也可以通过购买或者其他合法渠道获得脚本。您通过合法渠道获得的脚本的知识产权归脚本作者所有。您不得通过任何渠道获得任何违反中华人民共和国法律法规或侵犯第三方合法权益的脚本，您在使用任何脚本（包括但不限于通过易点软件渠道获得的脚本）前，应当自行审核脚本本身的安全性、合法性。否则，因上述事宜所产生的一切法律责任均由您承担，易点软件在此种情况下有权单方解除本协议，您应当同时负责赔偿易点软件遭受的全部损失，包括但不限于任何的赔偿金、补偿金、违约金、罚款、诉讼费、调查取证费、公证费、律师费等。 四、免责事由 您知悉并同意，易点软件不因下述任一情况而可能导致的任何损害赔偿承担责任，包括但不限于财产、收益、数据资料等方面的损失或其它无形损失： 因台风、地震、海啸、洪水、停电、战争、恐怖袭击等不可抗力之因素导致易点软件充值系统或服务不能正常运作。 由于黑客攻击、电信部门技术调整或故障、系统维护等原因而造成的系统服务中断或者延迟。 由于政府命令、法律法规的变更、司法机关及行政机关的命令、裁定等原因而导致的系统服务中断、终止或延迟。 由于您将授权码或易点软件帐户密码告知他人或未保管好自己的授权码密码或与他人共享易点软件帐户或任何其他非本公司的过错，导致您的个人资料泄露。 由于与本公司链接或合作的其它网站（如网上银行等）所造成的银行帐户信息、身份信息泄露及由此而导致的任何法律争议和后果。 您（包括未成年人用户）向本公司提供错误、不完整、不实信息等，造成不能使用易点软件帐户或遭受任何其他损失。 如因系统维护或升级的需要而需暂停网络充值服务时，我们将尽可能事先进行通告。对于充值服务的中断或终止而给您造成的任何损失，我们无须对您或任何第三方承担任何责任。 您已经充分阅读并同意易点软件刊登在网站上的《免责声明》 五、服务变更、中断或终止 鉴于服务的特殊性，您同意易点软件有权随时变更、中断或终止部分或全部的服务（包括收费服务及免费服务）。如变更、中断或终止的服务属于免费服务，易点软件无需通知用户，也无需对任何用户或任何第三方承担任何责任；如变更、中断或终止的服务属于收费服务，易点软件会在变更、中断或终止之前事先通知您，并向您提供等值的替代性的收费服务。如您不愿意接受替代性的收费服务，就您已经向易点软件支付的服务费，易点软件会按照您实际使用相应收费服务的情况，扣除相应服务费之后将剩余的服务费退还给您。如果易点软件服务就此终止的，易点软件会与您完成结算工作，但除退款外，不承担其他任何责任。 您明确知晓并理解，易点软件需要定期或不定期地对提供服务的平台或相关的设备进行检修或者维护，如因此类情况而造成收费服务在合理时间内的中断，易点软件无需为此承担任何责任，但易点软件应尽可能事先进行通告。 六、违约责任 如您违反本协议项下的任何规则、声明、承诺及保证，我们保留根据实际损失向您追究责任的权利。 七、法律适用与争议解决 本协议的订立、效力、解释、履行、修改和终止以及争议的解决适用中国的法律。因解释和履行本协议而发生的任何争议，本协议双方应首先通过友好协商的方式加以解决。如果在一方向其他方发出要求协商解决的书面通知后30天之内争议仍然得不到解决，则任何一方均有权向北京市顺义区人民法院提起诉讼。 八、隐私政策 易点软件将严格保护您的隐私。为服务用户的目的，易点软件可能通过使用您的个人信息，向您提供服务，包括但不限于向您发出产品和服务信息，或者与易点软件合作伙伴共享信息以便他们向您发送有关其产品和服务的信息。除此之外，您的个人信息将仅用于收集时即已确定并且经过您同意的目的，如有除此之外的任何其他用途，我们都会提前征得您的同意。在任何时候，您的信息均依照易点软件的隐私政策处理，并可在易点软件官网上浏览。 九、其他 易点软件不保证所有安卓设备均可正常运行易点软件，您应当在使用前先查询确认您的设备是否可以正常运行，易点软件不会因为您的设备无法正常运行易点软件向您退款。 本协议项下所有的通知均可通过重要页面公告等方式进行，该等通知于发送之日视为已送达您。 本协议构成双方对本协议之约定事项及其他有关事宜的完整协议，除本协议规定的，未赋予本协议各方其他权利。 如本协议中的任何条款无论因何种原因完全或部分无效或不具有执行力，本协议的其余条款仍应有效并且有约束力。 本协议中的标题仅为方便而设，不具法律或契约效果。 "},"zh-cn/declare.html":{"url":"zh-cn/declare.html","title":"免责声明","keywords":"","body":"免责声明 用户在接受易点软件平台及其关联网站（以下称“易点软件平台”）的服务（包括但不限于EC个人版、EC企业版服务等所有由易点软件提供的服务）之前， 请仔细阅读本免责声明并同意本声明的条款。 用户通过各种方式使用易点软件平台（包括安装使用易点软件平台所提供的软件等）服务的行为，将被视为已接受本声明所涉全部内容。 若用户对 本声明的任何条款有异议，请停止使用易点软件平台所提供的任何服务。 易点软件平台是以共建自动化测试脚本开发生态为理念，以用户需求为导向，通过先进的数据处理技术，为广大自动化测试脚本开发者脚本平台。 因脚本存在权利瑕疵或侵犯了 第三方的知识产权等任何合法权益，由脚本开发及提交者承担所有责任。因此给易点软件平台或 任何第三方造成损失的，脚本开发及提交者应承担任何可能需要支付给第三方的赔偿款等款项。 易点软件平台有权无需事先通知即可自行决定对脚本采取拒绝接入、下线、删除等处理措施 易点软件平台一贯高度重视知识产权保护并遵守中国各项知识产权法律、法规和具有约束力的规范性文件，重视正版，打击盗版。根据相关法律、法规和规范性文件要求，易点软件平台制定了旨在保护权利人的合法权益的措施和步骤，当权利人发现在脚本内容侵犯其任何合法权益时，权利人应事先向易点软件平台发出“权利通知”，易点软件平台将根据中国法律法规和规范性文件采取措施删除相关脚本内容。 具体措施和步骤如下： 一、权利通知 任何个人或单位如果发现易点软件平台用户或开发者利用易点软件平台及其服务侵害其合法权 益，请务必以书面的通讯方式向易点软件提交权利通知 请注意：如果权利通知的陈述失实，权利通知提交者将承担对由此造成的全部法律责任（包括但 不限于赔偿各种费用及律师费）。如果上述个人或单位不确定易点软件平台可获取的资料是否侵 犯了其合法权益，易点软件建议该个人或单位首先咨询专业人士。 为了易点软件平台有效处理上述个人或单位的权利通知，请提供以下内容： 1.权利人对涉嫌侵权内容拥有权利的权属证明； 2.要求删除的脚本的名称和具体明确的网站访问地址； 3.权利人具体的联络信息，包括姓名、身份证或护照复印件（对自然人）、单位登记证明复印件 （对单位）、通信地址、电话号码、传真和电子邮件； 4.请您签署相关文件，如果您是依法成立的机构或组织，请您加盖公章。 请您把以上资料和联络方式反馈至 ieasyclickmaster@hotmail.com 邮箱。 二、反通知 易点软件平台根据前述通知移除相关内容的，被移除内容的内容提供者可以依法向易点软件平台 发出关于被移除内容不侵犯著作权或其他合法权益的反通知。反通知发出后，易点软件平台可以 恢复被移除的内容，且依法对该恢复行为不承担法律责任。 请注意：如果您\"反通知\"的陈述失实，您将承担对由此造成的全部法律责任（包括但不限于赔偿 各种费用及律师费）。如果您不确定易点软件平台可获取的资料是否侵犯了他人的权利，我们建 议您首先咨询专业人士。 为了便于我们处理您的反对通知，请使用以下格式（包括各条款的序号）： 1.请指明被易点软件移除的信息或内容及其访问地址； 2.被移除内容的合法性证明，包括但不限于您对已移除的内容拥有著作权或其他合法权益的权属 证明或您可以合法使用该作品或该内容的证明； 3.请提供具体的联络信息，包括姓名、身份证或护照复印件（对自然人）、单位登记证明复印件 （对单位）、通信地址、电话号码、传真和电子邮件； 4.请您签署相关文件，如果您是依法成立的机构或组织，请您加盖公章。 请您把以上资料和联络方式反馈至 ieasyclickmaster@hotmail.com 邮箱。 知识产权归属 易点软件 以技术交流学习自动化测试为目的的初衷，不包含任何外挂、辅助等危害计算机信息的违法功能 如果您使用了易点软件，标示您已经充分理解与同意，必须遵守以下原则: 您开发的软件或者脚本归属权以及版权属于您自己，与易点软件无关。 您开发的软件出现问题，包括但不限于法律责任、软件异常，由您自己承担责任。 您不得用于开发非法软件，包括到不限于恶意注册、诈骗、危害国家、危害他人等非法软件。 您使用易点软件开发的软件，所有权利和责任都由您自己承担。 易点软件平台不保证服务不会中断。因运营策略调整、不可抗力、网络状况、通讯路线或管理部 门的要求等原因造成易点软件平台的服务无法正常提供的，易点软件平台不承担任何法律责任。 本免责声明的修改及更新权均属于易点软件平台所有。 "}}